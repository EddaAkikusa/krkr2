if (typeof Scripts.execSQ == "undefined") {
	Plugins.link("squirrel.dll");
}

if (typeof Array.save2 == "undefined") {
	Plugins.link("savestruct.dll");
}

if (typeof Storages.fstat == "undefined") {
	Plugins.link("fstat.dll");
}

/**
 * 基本概念になるレイヤ
 */
class GraphicLayerBase extends GraphicLayerEx {
	function GraphicLayerBase(isfore) {
		super.GraphicLayerEx(kag, isfore ? kag.fore.base : kag.back.base);
	}

	var _index = 0;
	property index {
		getter() {
			return _index;
		}
		setter(v) {
			_index = v;
			absolute = v;
		}
	}
};

/**
 * 基本概念になるボイストラック
 */
class VoiceTrack extends WaveSoundBuffer {

    var owner;

	/**
	 * コンストラクタ
	 */
    function VoiceTrack(owner) {
        this.owner = owner;
        super.WaveSoundBuffer(owner);
    }

	/**
	 * ボイスファイルを開く
	 */
	function open(storage) {
		if (!Storages.isExistentStorage(storage)) {
			var test = storage + ".ogg";
			if (Storages.isExistentStorage(test)) {
				storage = test;
			} else {
				test = storage + ".wav";
				if (Storages.isExistentStorage(test)) {
					storage = test;
				}
			}
		}
		super.open(storage);
	}
	
	/**
	 * ボイスの再生
	 */
    function play() {
		owner.setBGMVolDown(true);
		super.play(...);
    }

    var prevstatus = "unload"; // 直前のステータス

	/**
	 * ステータスの変更
	 */
    function onStatusChanged() {
        super.onStatusChanged(...);
        var ps = prevstatus;
        var cs = status;
        prevstatus = cs;
        if(ps == "play" && cs == "stop") {
			owner.setBGMVolDown(false);
		}
    }
}

KAGLoadScript('SceneParser.tjs');
KAGLoadScript('SceneListParser.tjs');
KAGLoadScript('VoiceListParser.tjs');
KAGLoadScript('VariableListParser.tjs');


/**
 * 基本プレイヤー
 */
class BasicPlayer extends KAGPlugin {

	// 環境情報
	var env;

	/**
	 * コンストラクタ
	 */
	function BasicPlayer() {
		env = new Environment(this, kag.scWidth, kag.scHeight);
		getSceneInfos();
		getVoiceInfos();
		getVariableInfos();
		sceneParser = new SceneParser();
	}

	/**
	 * ファイナライザ
	 */
	function finalize() {
		invalidate env;
		invalidate voiceInfos;
		invalidate sceneInfos;
		invalidate sceneNames;
	}

	// ---------------------------------------------------
	// シーン情報処理
	// ---------------------------------------------------

	var sceneNames; // シーン名前情報
	var sceneInfos; // シーン情報

	/**
	 * シーン情報の読み込み
	 */
	function getSceneInfos() {
		var parser = new SceneListParser();
		try {
			parser.parseStorage("scenes.csv");
			sceneNames = parser.sceneNames;
			sceneInfos = parser.sceneInfos;
		} catch (e) {
			dm(e.message);
			sceneNames = [];
			sceneInfos = %[];
		}
		invalidate parser;
	}

	// ---------------------------------------------------
	// ボイス情報処理
	// ---------------------------------------------------

	var voiceInfos; // ボイス再生用情報
	var voiceList;  // ボイス再生用情報
	
	/**
	 * シーン情報の読み込み
	 */
	function getVoiceInfos() {
		var parser = new VoiceListParser();
		try {
			parser.parseStorage("voices.csv");
			voiceInfos = parser.voiceInfos;
			voiceList  = parser.voiceList;
		} catch (e) {
			dm(e.message);
			voiceInfos = %[];
		}
		invalidate parser;
	}

	// ---------------------------------------------------
	// ボイス情報処理
	// ---------------------------------------------------

	var variableInfos; // 変数定義情報

	/**
	 * シーン情報の読み込み
	 */
	function getVariableInfos() {
		var parser = new VariableListParser();
		try {
			parser.parseStorage("variables.csv");
			variableInfos = parser.varInfos;
		} catch (e) {
			dm(e.message);
			variableInfos = [];
		}
		invalidate parser;
	}
	
	// ---------------------------------------------------
	// 共通処理
	// ---------------------------------------------------
	
	function dm(msg) {
		if (kag.debugLevel >= tkdlSimple) {
			global.dm(msg);
        }
	}

	/**
	 * スキップ中か
	 */
	function isSkip() {
		return kag.skipMode != SKIP_FORCE && (kag.skipMode || kag.noeffect);
	}

	/**
	 * 条件判定
	 */
	function eval(eval) {
		return Scripts.eval(eval);
	}
	
	// --------------------------------------------------------
	// シーンコンバート処理
	// --------------------------------------------------------

	var sceneParser     = new SceneParser(); // パーサ

	/**
	 * シーンファイルを変換してデータとして取得する
	 * @param name シーン名
	 * @param voiceNameMap
	 */
	function getScene(name, voiceNameMap, labelMap) {
		var info = sceneInfos[name];
		var voiceBase;
		if (info !== void) {
			voiceBase = info.voiceBase;
		}
		// パース実行
		var ret = sceneParser.parse(name, voiceInfos, voiceBase, voiceNameMap, labelMap);
		// エラー情報表示
		var errors = sceneParser.errors;
		for (var i=0;i<errors.count;i++) {
			error(errors[i]);
		}
		return ret;
	}

	/**
	 * 次シーン判定処理
	 * @param name 現在のシーン名
	 */
	function getNextScene(name) {
		if (name !== void && name !== null && name != "") {
			var info = sceneInfos[name];
			if (info !== void) {
				var next = info.next;
				if (next !== void) {
					for (var i=0;i<next.count;i++) {
						if (next.cond === void || next.cond == "" || eval(next.cond)) {
							return next.scene;
						}
					}
				}
			}
		}
	}

	// ------------------------------------------------------------------
	// 画面切り替え関連
	// ------------------------------------------------------------------

    /**
     * トランジション情報の取得
     */
    function getTrans(name, elm) {
		// 名前指定で上書き
		var tr = %[];
		if (name == "void" || name == "none") {
			return tr;
		}
		var info;
		if (env.transitions !== void && (info = env.transitions[name]) !== void) {
			//dm("登録ずみのトランジション:" + name);
			// コピー
			(Dictionary.assign incontextof tr)(info, false); 
			// パラメータのコピー
			if (tr.method == "layer") {
				foreach(elm, function(name, value, elm, tr) {
					if (layerTransitionParam[name] !== void) {
						tr[name] = value;
					}
				}, tr);
			} else {
				foreach(elm, function(name, value, elm, tr) {
					if (transitionParam[name] !== void) {
						tr[name] = value;
					}
				}, tr);
			}
			return tr;
		} else if (elm != null) {
			if (transitionName[name] !== void || name.substring(0,5) == "trans") {
				//dm("規定のシステムトランジション:" + name);
				var tr = %[];
				// パラメータのコピー
				foreach(elm, function(name, value, elm, tr) {
					if (transitionParam[name] !== void) {
						tr[name] = value;
					}
				}, tr);
				tr.method = name;
				return tr;
			} else if (layerTransitionName[name] !== void || name.substring(0,5) == "layer") {
				//dm("規定のレイヤトランジション:" + name);
				var tr = %[];
				// パラメータのコピー
				foreach(elm, function(name, value, elm, tr) {
					if (layerTransitionParam[name] !== void) {
						tr[name] = value;
					}
				}, tr);
				tr.method = "layer";
				tr.type   = name;
				return tr;
			}
		}
    }
	
	function backup() {
		kag.fore.base.stopTransition();
		kag.backupLayer(EMPTY, true);
	}

	/*
	 * トランジション実行エントリ
	 * @param trans トランジション情報
	 * KAG にトランジション実行命令を差し込む
	 */
	function beginTransition(trans) {
		if (trans === void || trans.method === void || trans.time == 0 || isSkip()) {
			addTag("forelay");
		} else {
			// 実際のトランジション実行
			trans.children = true;
			if (trans.method === void) {
				trans.method = "crossfade";
			}
			addTag("trans", trans);
			if (trans.transwait !== void) {
				// 時間待ち
				addTag("wait", %[ time : (int)trans.time + (int)trans.transwait, trans:true ]);
			} else {
				// トランジション待ち
				addTag("wt");
			}
		}
		// メッセージ窓状態同期
		addTag("syncmsg");
	}

	/**
	 * レイヤ画面切り替えの開始
	 */
	function beginLayerTrans(elm) {
		return kag.tagHandlers.ltbegin(elm);
	}

	/**
	 * レイヤ画面切り替えの終了
	 */
	function endLayerTrans(elm) {
		return kag.tagHandlers.ltend(elm);
	}
	
	/**
	 * アクション情報のコピー
	 * @param act  元アクション情報
	 * @param time 時間上書き指定
	 * @param elm  タグによる上書き用パラメータ情報
	 * @return システム登録用アクション情報
	 */
	function copyActionInfo(act, time, elm) {
		var action = %[];
		if (act !== void) {
			var names = [];
			names.assign(act);
			if (act.module !== void) {
				//dm("module 指定アクション:" + act.module);
				if (typeof act.module != "String") {
					throw new Exception("アクションモジュール名は文字列指定してください");
				}
				var module = Scripts.eval(act.module);
				if (module !== void) {
					// 旧スタイル
					for (var i=0; i<names.count; i+= 2) {
						var name = names[i];
						var elm  = names[i+1];
						action[name] = elm;
					}
					if (time !== void) {
						action.time = time;
					}
					// パラメータのコピー
					if (elm !== void) {
						foreach(elm, function(name, value, elm, action) {
							if (actionParam[name] !== void) {
								action[name] = value;
							}
						}, action);
					}
					// 新スタイルに置き換え
					action = module(action);
				}
			} else {
				// 新スタイル
				for (var i=0; i<names.count; i+= 2) {
					var name  = names[i];
					var value = names[i+1];
					if (value instanceof "Dictionary") {
						// 辞書の場合はクローンして時間指定
						var e = %[];
						(Dictionary.assign incontextof e)(value);
						if (time !== void) {
							e.time = time;
						}
						// パラメータのコピー
						if (elm !== void) {
							e.time   = +elm.time if elm.time !== void;
							e.delay  = +elm.delay if elm.delay !== void;
						}
						action[name] = e;
					} else {
						// そうでない場合はそのまま
						action[name] = value;
					}
				}
			}
		}
		if (elm !== void) {
			action.nowait = +elm.nowait if elm.nowait !== void;
		}
		return action;
	}

	/**
	 * 表示/消去アクションの実行
	 */
	function beginTransAction(trans, layer, hide, nosync) {
		// アクション実行
		var action = copyActionInfo(hide ? trans.hideaction : trans.showaction, trans.time);
		action["visvalue"] = %[ handler:MoveAction, value: hide ? 0 : 100, time:trans.time ];
		addTag("action", %[target:layer, action:action]);
		//dm("表示アクション実行");
		if (!nosync && !trans.nosync) {
			if (trans.transwait !== void) {
				// 時間待ち
				addTag("wait", %[ time : (int)trans.time + (int)trans.transwait, action:true ]);
			} else {
				// アクション待ち
				addTag("wact", %[ target:layer ]);
			}
		}
	}

	/**
	 * アクションの終了を待たせる
	 * @param layer 対象レイヤ
	 * @param syncMode シンクロ指定
	 * @param movieSyncMode ムービー同期
	 */
	function waitAction(layer, syncMode, movieSyncMode) {
		// シンクロ指定
		if (syncMode) {
			return kag.waitAction(layer);
		}
		// ムービー同期
		if (movieSyncMode) {
			return kag.waitLayerMovie(layer);
		}
	}

	// ------------------------------------------------------------------
	// 環境レイヤ制御
	// ------------------------------------------------------------------

	/**
	 * 表示位置指定
	 * 値的には 0〜4096 の範囲で
	 * stage     200
	 * level 0:  400
	 * level 1:  800
	 * level 2: 1200
	 * level 3: 1600
	 * level 4: 2000
	 * event    2200
	 * level 5: 2400
	 * level 6: 2800
	 * level 7: 3200
	 * level 8: 3600
	 * msg      3800
     * level 9: 4000
	 */
	
	// 現在前面にあるレイヤ一覧
	var forelayers = [];

	/**
	 * 指定したレイヤを指定したレベルに移動する
	 */
	function toLevel(layer, newlevel) {

		//dm("レベル指定:" + newlevel + ":" + layer.level);
		newlevel = +newlevel;

		if (layer.level > 0) {
			if (layer.level === newlevel) {
				//dm("同一レベルなので処理しない");
				return;
			}
			var index = layer.index;
			// もともといたレベルの調整
			for (var i = 0; i<forelayers.count; i++) {
				var target = forelayers[i];
				if (target !== layer && target.level == layer.level) {
					if (target.index > index) {
						target.index --;
					}
				}
			}
		}
		// 新規レベルの一番上にもっていく
		var newindex = (newlevel + 1) * 400;
		for (var i = 0; i<forelayers.count; i++) {
			var target = forelayers[i];
			if (target !== layer && target.level == newlevel && target.index > newindex) {
				newindex = target.index;
			}
		}
		newindex++;
		//dm("レベル設定:" + newlevel + ":" + newindex);
		layer.index = newindex;
		layer.level = newlevel;
    }
	
	/**
	 * 同じレベルのレイヤの中で最前列に移動
	 */
	function toFront(layer) {
		var level = layer.level;
		var index = layer.index;
		var maxindex = index;
		for(var i = 0; i<forelayers.count; i++) {
			var target = forelayers[i];
			if (target !== layer && target.level == level) {
				if (target.index > maxindex) {
					maxindex = target.index;
				}
				if (target.index > index) {
					target.index--;
				}
			}
		}
		layer.index = maxindex;
	}

	/*
	 * レイヤを最後列に移動
	 */
	function toBack(layer) {
		var level = layer.level;
		var index = layer.index;
		var minindex = index;
		for(var i = 0; i<forelayers.count; i++) {
			var target = forelayers[i];
			if (target !== layer && target.level == level) {
				if (target.index < minindex) {
					minindex = target.index;
				}
				if (target.index < index) {
					target.index++;
				}
			}
		}
		layer.idnex = minindex;
    }

	/**
	 * 表にあるレイヤか？
	 */
	function isForeLayer(layer) {
		return layer.parent === kag.fore.base;
	}

	/**
	 * 表に移動させる
	 */
	function toForeLayer(layer) {
		var index    = layer.index;
		layer.parent = kag.fore.base;
		layer.index  = index;
	}

	/**
	 * レイヤ取得処理
	 * @param fore
	 * @param origLayer 廃棄元レイヤ
	 * @param trash orig を廃棄するかどうか
	 */
	function getNewLayer(owner, isfore, origLayer, trash=true) {
		var newlayer = owner.createLayer(isfore);
		newlayer.hitType = htProvince;
		newlayer.level = -1;
		forelayers.add(newlayer);
		if (origLayer !== void) {
			newlayer.assign(origLayer);
			newlayer.assignVisibleState(origLayer);
			newlayer.level = origLayer.level;
			newlayer.index = origLayer.index;
			if (trash) {
				trashLayer(origLayer);
			}
		}
		return newlayer;
	}
	
	// 廃棄対象レイヤ一覧
	var trashlayers = [];

	/**
	 * レイヤ廃棄処理
	 * @param layer
	 */
	function trashLayer(layer) {
		if (layer !== void) {
			forelayers.remove(layer);
			for (var i=0;i<trashlayers.count;i++) {
				if (trashlayers[i] === layer) {
					return;
				}
			}
			trashlayers.add(layer);
		}
		return void;
	}

	/**
	 * レイヤ破棄実行
	 */
	function clearTrash() {
		//dm("レイヤ破棄実行");
		for (var i=0;i<trashlayers.count;i++) {
			invalidate trashlayers[i];
		}
		trashlayers.clear();
	}

	
	// -------------------------------------------------------------------
	// ボイス処理系
	// -------------------------------------------------------------------

	// ボイスをカットするか
	property voicecut {
		getter() {
			return kag.sflags.voicecut;
		}
	}

	// 改ページ後にボイスカット
	property voicecutpage {
		getter() {
			return kag.sflags.voicecutpage;
		}
	}

	// ボイス再生時に bgm音量を下げる
	property bgmdown {
		getter() {
			return kag.sflags.bgmdown;
		}
		setter(v) {
			kag.sflags.bgmdown = v;
		}
	}
	
	// 名前定義がデフォルト名か？
	function isDefaultName() {
		return kag.flags.name === void || (kag.flags.name == kag.defaultName && kag.flags.family == kag.defaultFamily);
	}

	// ----------------------------------------------------------------------------

	// ボイス用トラック
	var voiceTracks = %[];
	
	/**
	 * ボイス再生
	 * @param name キャラ名
	 * @param voicefile 再生ファイル
	 */
	function playVoice(name, voicefile) {

		if (isSkip() || !kag.voiceenable) {
			return;
		}

		// ボイス情報取得
		var info = voiceInfos[name];
		var configName = info !== void && info.config !== void ? info.config : "etc";

		// ボイス再生OFFチェック
		if (!kag.getVoiceOn(configName)) {
			return;
		}
		var ret = void;
		var soundBuffer = voiceTracks[name];
		if (soundBuffer === void) {
			soundBuffer = new VoiceTrack(this);
			voiceTracks[name] = soundBuffer;
		}
		soundBuffer.volume2 = kag.getVoiceVolume(configName) * 1000;
		try {
			if (kag.voicespeed != 1.0 && typeof soundBuffer.filters != "undefined") {
				soundBuffer.filters.clear();
				soundBuffer.filters.add(new WaveSoundBuffer.PhaseVocoder());
				soundBuffer.filters[0].window = 256;
				soundBuffer.filters[0].time = 1.0 / kag.voicespeed;
				soundBuffer.open(voicefile);
				soundBuffer.play();
				ret = (int)(soundBuffer.totalTime / kag.voicespeed);
			} else {
				soundBuffer.open(voicefile);
				soundBuffer.play();
				ret = soundBuffer.totalTime;
			}
		} catch (e) {
		}
		return ret;
	}

	/**
	 * ボイス停止
	 * @param name キャラ名
	 */
	function stopVoice(name) {
		var soundBuffer = voiceTracks[name];
		if (soundBuffer !== void) {
			soundBuffer.stop();
			if (typeof soundBuffer.filters != "undefined") {
				soundBuffer.filters.clear();
			}
        }
	}

	/**
	 * 全ボイス停止
	 */
	function stopAllVoice() {
		var names = [];
		names.assign(voiceTracks);
        for (var i=0; i<names.count; i+= 2) {
			var soundBuffer = names[i+1];
			soundBuffer.stop();
			if (typeof soundBuffer.filters != "undefined") {
				soundBuffer.filters.clear();
			}
		}
	}
	
	/**
	 * ボイスまち
	 * @param name キャラ名
	 * @param canSkip スキップできる
	 */
	function waitVoice(name, canSkip) {
		var soundBuffer = voiceTracks[name];
		if (soundBuffer !== void && soundBuffer.status == "play") {
			var remainTime = (soundBuffer.totalTime - soundBuffer.position) / kag.voicespeed;
			if (remainTime > 0) {
				return kag.waitTime(remainTime, canSkip && kag.clickSkipEnabled);
			}
		}
		return 0;
	}
	
    /**
     * ボイスのボリュームの再調整
	 * @param name キャラ名
	 * @param configName キャラボイス用識別名
     */
	function resetVoiceVolume(name, configName) {
		var soundBuffer = voiceTracks[name];
		if (soundBuffer !== void) {
			soundBuffer.volume2 = kag.getVoiceVolume(configName) * 1000;
        }
    }

	// -------------------------------------------------------------------
	// 履歴処理用
	// -------------------------------------------------------------------

	/**
	 * 履歴に名前とボイスを登録
	 */
	function setHistory(name, voices) {
		if (kag.historyWriteEnabled) {
			if (typeof kag.historyLayer.storeName !== 'undefined') {
				kag.historyLayer.storeName(name);
			} else {
				if (name != "") {
					kag.historyLayer.store(name + " ");
				}
			}
			// ボイス再生の登録
			kag.historyLayer.setNewAction("kag.scenePlayer.playVoices(" + valueToString(voices) + ")");
		}
	}
	
	// 履歴のアクション消去
	function clearHistory(reline) {
		if (kag.historyWriteEnabled) {
			// アクション（ボイス再生) を解除
			kag.historyLayer.clearAction();
			if (reline) {
				kag.historyLayer.reline();
			}
        }
	}

	// -------------------------------------------------------------------
	
	// 自動待ちの追加
	function addAutoWait(wait) {
		kag.addAutoWait(wait);
	}

	// ------------------------------------------------------------
	// SE 系機能
	// ------------------------------------------------------------

	property nosewhenskip {
		getter() {
			return kag.nosewhenskip;
		}
	}

	property senum {
		getter() {
			return kag.numSEBuffers;
		}
	}
	
	function waitSEFade(wait) {
		return kag.waitSEFade(wait);
	}

	function waitSEStop(wait) {
		return kag.waitSEStop(wait);
	}

	function playSE(id, time, play) {
		time = isSkip() ? 0 : +time;
		if (time > 0)  {
			kag.se[id].fadeIn(%[ storage:play.storage, loop:play.loop, time:time, start:play.start]);
		} else {
			kag.se[id].play(%[ storage:play.storage, loop:play.loop, start:play.start]);
		}
	}

	function fadeSE(id, time, volume) {
		time = isSkip() ? 0 : +time;
		if (time > 0) {
			kag.se[id].fade(%[time:time, volume:volume]);
		} else {
			kag.se[id].volume = volume;
		}
	}
	
	function stopSE(id, time) {
		time = isSkip() ? 0 : +time;
		if (time > 0) {
			kag.se[id].fadeOut(%[time:time]);
		} else {
			kag.se[id].stop();
		}
	}

	// ------------------------------------------------------------
	// BGM 系機能
	// ------------------------------------------------------------

	function waitBGMFade(wait) {
		return kag.waitBGMFade(waitFade);
	}

	function waitBGMStop(wait) {
		return kag.waitBGMStop(wait);
	}

	function setBGMVolDown(down) {
		if (down) {
			if (bgmdown && !isSkip()) {
				kag.bgm.voldown = true;
			}
		} else {
			if (kag.bgm.voldown) {
				kag.bgm.voldown = false;
			}
		}
	}
	
	function playBGM(time, play) {
		time = isSkip() ? 0 : +time;
		if (play.noxchg) {
			if (time > 0)  {
				kag.bgm.fadeIn(%[ storage:play.storage, loop:play.loop, time:time, start:play.start]);
			} else {
				kag.bgm.play(%[ storage:play.storage, loop:play.loop, paused:play.paused, start:play.start]);
			}
		} else {
			if (time > 0 || +play.intime > 0) {
				kag.bgm.exchange(%[ storage:play.storage, loop:play.loop, time:time, intime:play.intime, outtime:play.outtime, overlap:play.overlap, start:play.start]);
			} else {
				kag.bgm.play(%[ storage:play.storage, loop:play.loop, paused:play.paused, start:play.start]);
			}
		}
		kag.clearBgmStop();
		kag.clearBgmLabel();
	}

	function pauseBGM(time) {
		time = isSkip() ? 0 : +time;
		if (time > 0) {
			kag.bgm.fadePause(%[ time:time ]);
		} else {
			kag.bgm.pause();
		}
	}
	
	function resumeBGM() {
		kag.bgm.resume();
	}

	function fadeBGM(time, volume) {
		time = isSkip() ? 0 : +time;
		if (time > 0) {
			kag.bgm.fade(%[time:time, volume:volume]);
		} else {
			kag.bgm.setVolume(volume * 1000);
		}
	}
	
	function stopBGM(time) {
		time = isSkip() ? 0 : +time;
		if (time > 0) {
			kag.bgm.fadeOut(%[ time:time ]);
		} else {
			kag.bgm.stop();
		}
	}

	// ------------------------------------------------------
	// エラー処理系
	// ------------------------------------------------------

	function errorImage() {
		kag.errorImage(...);
	}

	function errorCmd() {
		kag.errorCmd(...);
	}
	
	function error() {
		kag.error(...);
	}

	function errorVoice() {
		kag.errorVoice(...);
	}

	// ------------------------------------------------------
	// フラグ処理系
	// ------------------------------------------------------

	function setBGMFlag(name) {
		kag.sflags["bgm_" + (name.toUpperCase())] = true;
	}

	function setCGFlag(name) {
		kag.sflags["cg_" + (name.toUpperCase())] = true;
	}

	function setMovieFlag(name) {
		kag.sflags["movie_" + (name.toUpperCase())] = true;
	}

	// --------------------------------------------------------------
	// KAG の諸機能
	// --------------------------------------------------------------

	// --------------------------------------------------
	// テキスト系
	
	function tag_ch() {
		return isJump() ? 0 : kag.tagHandlers.ch(...);
	}

	function tag_r() {
		return isJump() ? 0 : kag.tagHandlers.r(...);
	}

	function tag_ruby() {
		return isJump() ? 0 : kag.tagHandlers.ruby(...);
	}

	function tag_font() {
		return kag.tagHandlers.font(...);
	}

	function tag_deffont() {
		return kag.tagHandlers.deffont(...);
	}

	function tag_resetfont() {
		return kag.tagHandlers.resetfont(...);
	}

	function tag_style() {
		return kag.tagHandlers.style(...);
	}

	function tag_defstyle() {
		return kag.tagHandlers.defstyle(...);
	}

	function tag_resetstyle() {
		return kag.tagHandlers.resetstyle(...);
	}

	function tag_l() {
		return isJump() ? 0 : kag.tagHandlers.l(...);
	}

	function tag_p() {
		return isJump() ? 0 : kag.tagHandlers.p(...);
	}

	function tag_er() {
		return isJump() ? 0 : kag.tagHandlers.er(...);
	}

	function tag_indent() {
		return kag.tagHandlers.indent(...);
	}
	
	function tag_endindent() {
		return kag.tagHandlers.endindent(...);
	}

	function tag_delay() {
		return kag.tagHandlers.delay(...);
	}

	// --------------------------------------------------
	// 制御系
	
	function tag_cancelskip() {
		return kag.tagHandlers.cancelskip(...);
	}

	function tag_resetwait() {
		return kag.tagHandlers.resetwait(...);
	}
	
	function tag_wait() {
		return isJump() ? 0 : kag.tagHandlers.wait(...);
	}

	function tag_waittrig() {
		return isJump() ? 0 : kag.tagHandlers.waittrig(...);
	}
	
	function tag_beginskip() {
		return kag.tagHandlers.beginskip(...);
	}

	function tag_endskip() {
		return kag.tagHandlers.endskip(...);
	}
	
	// --------------------------------------------------
	// 画面制御系
	
	function tag_backlay() {
		return kag.tagHandlers.backlay(...);
	}

	function tag_forelay() {
		return kag.tagHandlers.forelay(...);
	}
	
	function tag_trans() {
		return kag.tagHandlers.trans(...);
	}

	function tag_wt() {
		return isJump() ? 0 : kag.tagHandlers.wt(...);
	}
	
	function tag_action() {
		return kag.tagHandlers.action(...);
	}
	
	function tag_stopaction() {
		return kag.tagHandlers.stopaction(...);
	}

	function tag_wact() {
		return isJump() ? 0 : kag.tagHandlers.wact(...);
	}

	// --------------------------------------------------
	// 変数系
	
	function tag_eval(elm) {
		return kag.tagHandlers.eval(...);
	}

	function tag_set(elm) {
		if (elm.name !== void && elm.value !== void) {
			var name = elm.name;
			if (name.substring(0,3) == "sf.") {
				sf[name.substring(3)] = elm.value;
			} else if (name.substring(0,2) == "f.") {
				f[name.substring(2)] = elm.value;
			}
		}
		return 0;
	}

	// --------------------------------------------------------------
	// メッセージ窓制御
	// --------------------------------------------------------------

	/**
	 * メッセージ窓の初期化
	 */
	function tag_msgwin(elm) {
		kag.setCurrentMessageLayer(%[layer:"message0"]);
		var msg = kag.fore.messages[kag.currentNum];
		msg.setPosition(elm);
		if (env.envinfo.nameImageMap !== void) {
			msg.setNameImage(env.envinfo.nameImageMap);
		}
		return 0;
	}

	/**
	 * メッセージ表示同期
	 */
	function tag_syncmsg(elm) {
		return kag.tagHandlers.syncmsg(elm);
	}

	/**
	 * メッセージ窓のON/OFF
	 */
    function msgonoff(elm, v) {
		kag.setCurrentMessageLayerVisibleFast(0, v);
		kag.setCurrentMessageLayerVisibleFast(1, v);
		return 0;
	}

	/**
	 * メッセージ窓の表示
	 */
	function tag_msgon(elm) {
		return msgonoff(elm, true);
	}

	/**
	 * メッセージ窓の消去
	 */
	function tag_msgoff(elm) {
		return msgonoff(elm, false);
	}

	/**
	 * 名前の表示
	 * @param name 表示名
	 * @param faceName 表情名
	 * @param voices 再生ボイスデータ
     */
	function drawName(name, faceName, voices) {
		
		setHistory(name, voices);

		// メッセージ窓
		var msg = kag.fore.messages[kag.currentNum];

		// 名前の表示
		msg.processName(name);

		// 表情表示
		var faceLayer = msg.faceLayer;
		if (faceLayer !== void) {
			if (faceName !== void) {
				try {
					faceLayer.loadImages(faceName);
				} catch (e) {
					errorImage(name + ":表情画像がロードできません");
				}
				faceLayer.visible = true;
			} else {
				faceLayer.visible = false;
			}
		}
    }

    /**
     * 行待ち終了後に呼び出される処理
     */
	function tag_afterline(elm) {
		clearHistory();
		return 0;
    }

    /**
     * ページ処理後に呼び出される処理
     */
	function tag_afterpage(elm) {
		clearHistory(true);
		kag.stopAllActions();
		return 0;
    }

	/**
	 * 全ボイスの停止
	 */
	function tag_stopallvoice(elm) {
		stopAllVoice();
	}

	// ---------------------------------------------------
	// 選択肢用処理
	// ---------------------------------------------------

	function addSelect(elm) {
		if (f.selectInfos == void) {
			f.selectInfos = [];
		}
		if (f.selectDoneFlag) {
			f.selectInfos.clear();
			f.selDoneTarget  = void;
			f.selectDoneFlag = false;
		}
		var e = %[];
		(Dictionary.assign incontextof e)(elm,false);
		f.selectInfos.add(e);
		return 0;
	}

    /**
     * 選択肢の表示
     */
	function doSelect(elm)
	{
		f.selectDoneFlag = true;
		f.selDoneTarget  = elm.target  if elm.target  !== void;
		f.selTarget      = void;
		// 終了処理をさしこむ
		addTag("er");
		addTag("selend");
		
		// f.selectInfo の内容で選択肢を表示
		if (env.envinfo.selectopt !== void) {
			kag.setSelectOptions(env.envinfo.selectopt);
		}
		kag.showSelect();
		return kag.waitTrigger(%[name:"selectdone"]);
	}

	/**
	 * 選択肢の終了
	 */
	function endSelect(elm) {
		kag.hideSelect();
		if (f.selTarget != '') {
			goToLabel(f.selTarget);
			return 0;
		} else {
			return -1;
		}
	}

	/**
	 * 選択肢処理の完了
	 */
	function doneSelect(elm) {
		if (f.selDoneTarget != "") {
			goToLabel(f.selDoneTarget);
			return 0;
		} else {
			return -1;
        }
	}
	
	/**
	 * 選択肢処理の完了
	 */
	function optSelect(elm) {
		kag.setSelectOptions(elm);
		return 0;
	}

	// --------------------------------------------------------------
	// KAG からの処理呼び出し
	// --------------------------------------------------------------

    /**
	 * ボイス速度変更
	 */
	function onVoiceSpeed() {
		foreach(voiceTracks, function(name, value, dict) {
			invalidate value;
		});
		voiceTracks = %[];
	}
	
	/**
	 * SE 用情報のクリア
	 */
	function onSeStop(id) {
		env.onSeStop(id);
	}

	/**
	 * 表裏コピーが実行された場合の処理
	 */
	function onCopyLayer(toback, backlay) {
		env.onCopyLayer(toback, backlay);
		if (backlay && !toback) {
			clearTrash();
		}
	}

	/**
	 * トランジション終了時処理
	 */
	function onExchangeForeBack() {
		clearTrash();
	}

	/**
	 * 全リセット時の処理
	 */
	function onResetAll() {
		env.resetEnv();
		env.syncAll();
	}

	/**
	 * レイヤ消去指定
	 */
	function onClearLayers(isfore) {
		if (isfore) {
			env.hideAll();
			env.syncAll();
			clearTrash();
		}
	}
	
	// --------------------------------------------------------------
	// KAG 用保存処理
	// --------------------------------------------------------------

	/**
	 * 保存実行
	 */
	function doSave() {
		kag.pushHistoryOfStore();
		kag.storeFlags();
		kag.storeLabelPassed = true;
		kag.setMenuAccessibleAll();
	}

	/**
	 * 状態保存処理
	 */
	function onStore(f, elm) {
		var dic = f.env = %[];
		save(dic);
	}

	/**
	 * 状態復帰処理
	 */
	function onRestore(f, clear, elm) {
		if (f.env !== void) {
			load(f.env);
		}
	}

	// --------------------------------------------------------------
	// KAG 用コマンド拡張インターフェース
	// --------------------------------------------------------------

	// シーン再生処理用 tick
	var tick;

	// シーンパーサの初期化
	function sceneinit(elm) {
		sceneParser.clear();
		return 0;
	}

	// シーン用マクロの読み込み
	function scenemacro(elm) {
		sceneParser.parseMacro(elm.storage);
		return 0;
	}

	// シーン用オプション指定
	function sceneopt(elm) {
		sceneParser.setOption(elm);
		return 0;
	}

	// シーン再生開始
	function scenestart(elm) {
		kag.prevSkipMode = void;
		tick = System.getTickCount();
		run(elm.storage);
		return 0;
	}

	// シーン再生メイン処理
	function scenemain(elm) {
		var now = System.getTickCount();
		var diff = now - tick;
		tick = now;
		//dm("シーンメイン:" + tick + ":" + diff);
		var step = main(diff);
		//dm("シーン返り値:" + step);
		switch (step) {
		case -5: // イベント待ち
		case -4: // イベント待ち
			//dm("処理継続");
			return -5;
		case -3: // ブレーク
		case -2:
			//dm("ブレーク");
			return -3;
		case -1: // 終了
			//dm("終了");
			return 0;
		}
		if (step >= 0) {
			//dm("処理継続");
			kag.insertTag(void, elm);
			return step;
		}
	}

	// ------------------------------------------------------
	// コンバート処理
	// ------------------------------------------------------

	function getTime(name) {
		if (Storages.isExistentStorage(name)) {
			try {
				var stat = Storages.fstat(name);
				if (stat.mtime !== void) {
					return stat.mtime.getTime();
				} else {
					return 0;
				}
			} catch (e) {
				return 0;
			}
		} else {
			return 0;
		}
	}

	var convertAll;

	function getVoiceNameMap(path) {
		var voiceNameMap = %[];
		var voiceNameList = [];
		voiceNameList.load(path + "VOICE_ID.lst");
		var cnt = 0;
		for (var i=0;i<voiceNameList.count;i++) {
			var name = voiceNameList[i];
			if (name.charAt(0) != '[') {
				name = Storages.chopStorageExt(Storages.extractStorageName(name));
				voiceNameMap[name.toUpperCase()] = cnt++;
			}
		}
		return voiceNameMap;
	}

	// システムボイス情報
	function getSysVoiceInfos(path) {
		var voiceNameMap = getVoiceNameMap(path);
		var sysVoiceList = [];
		var sysVoiceMap = %[];
		try {
			sysVoiceList.load("sysvoices.csv");
			for (var i=0;i<sysVoiceList.count;i++) {
				var name = sysVoiceList[i];
				if (name.charAt(0) != '#') {
					name = name.toUpperCase();
					var value = voiceNameMap[name];
					//dm("システムボイス:" + name + ":" + value);
					if (value !== void) {
						sysVoiceMap[name] = value;
					}
				}
			}
		} catch (e) {
			dm(e);
		}
		return sysVoiceMap;
	}
	
	/**
	 * コンバート処理の実行
	 * @path 格納先パス
	 */
	function convert(path = "", all=false) {

		convertAll = all;
		askYesNo((all ? "再" : "") + "コンバート処理を実行します。コンバート実行中は処理が固まるのでご注意ください", "確認", function(path) {
			
			var envtime = getTime("envinit.tjs");
			var voicetime = getTime("voices.csv");
			var labelMapName = System.exePath + "labelMap.tjs";
			
			if (path.length > 0 && path[path.length - 1] != '/') {
				path += "/";
			}
			// ボイスリストの読み込み
			var voiceNameMap = getVoiceNameMap(path);

			// ラベルマップを読み込み
			var labelMap;
			try {
				labelMap = Scripts.evalStorage(labelMapName);
			} catch (e) {
				labelMap = %[count:0];
			}
			var labelMapCount = labelMap.count;
			
			var list = [ "[SCENE_ID]" ];
			for (var i=0;i<sceneNames.count;i++) {
				var name = path + "SCENE/" + Storages.chopStorageExt(sceneNames[i]) + ".nut";
				list.add("SCENE\\" + Storages.chopStorageExt(sceneNames[i]) + ".nut");
				var srctime  = getTime(sceneNames[i]);
				var desttime = getTime(name);
				//dm("%s: src:%d dest:%d env:%d voice:%d\n".sprintf(name, desttime, srctime, envtime, voicetime));
				if (convertAll || desttime < srctime || desttime < envtime || desttime < voicetime) {
					dm("convert file:" + sceneNames[i]);
					Scripts.saveSQ(name, getScene(sceneNames[i], voiceNameMap, labelMap));
				}
			}
			list.add("[END]");
			list.save2(path + "SCENE_ID.LST");

			if (labelMapCount != labelMap.count) {
				(Dictionary.saveStruct incontextof labelMap)(labelMapName); // ラベルマップを追加保存
			}
			
			System.inform("コンバート処理が終了しました");
		} incontextof this, void, path);
	}

	function convertParam(path = "") {
		askYesNo("パラメータ出力を実行します", "確認", function(path) {
			if (path.length > 0 && path[path.length - 1] != '/') {
				path += "/";
			}
			Scripts.saveSQ(path + "SCENE/" + "envinit.nut", env.envinfo);
			Scripts.saveSQ(path + "SCENE/" + "voices.nut",  voiceList);
			Scripts.saveSQ(path + "SCENE/" + "scenes.nut",  sceneInfos);
			Scripts.saveSQ(path + "SCENE/" + "variables.nut",  variableInfos);
			Scripts.saveSQ(path + "SCENE/" + "sysvoices.nut", getSysVoiceInfos(path));
			System.inform("パラメータ出力が完了しました");
		} incontextof this, void, path);
	}
};

KAGLoadScript('YAML.tjs');

/**
 * 空の辞書
 */
var EMPTY = %[];

/**
 * 鍵の内容を表示する
 * @param name 名称
 * @param dict 辞書オブジェクト
 */
function showKeys(name, dict) {
    if (kag.debugLevel >= tkdlVerbose) {
        name += ":";
        if (dict) {
            var array = [];
            array.assign(dict);
            for (var i=0; i<array.count; i+= 2) {
                if (i != 0) {
                    name += ",";
                }
                name += (array[i] + ":" + array[i+1]);
            }
            dm(name);
        }
    }
}

var transitionName = %[
    "universal" => true,
    "crossfade" => true,
    "scroll" => true,
    "wave" => true,
    "mosaic" => true,
    "turn" => true,
    "rotatezoom" => true,
    "rotatevanish" => true,
    "rotateswap" => true,
    "ripple" => true,
    ];

var transitionParam = %[
    "time" => true,
    "rule" => true,
    "vague" => true,
    "from" => true,
    "stay" => true,
    "wavetype" => true,
    "maxh" => true,
    "maxomega" => true,
    "bgcolor1" => true,
    "bgcolor2" => true,
    "mosaic" => true,
    "maxsize" => true,
    "turn" => true,
    "bgcolor" => true,
    "factor" => true,
    "accel" => true,
    "twistaccel" => true,
    "twist" => true,
    "centerx" => true,
    "centery" => true,
    "rwidth" => true,
    "roundness" => true,
    "speed" => true,
    "maxdrift" => true,
    "msgoff" => true,
    "charoff" => true,
    "transwait" => true,
	"showaction" => true,
	"hideaction" => true
    ];

var layerTransitionName = %[
	"wipeltor" => true,
	"wipertol" => true,
	"layfade"  => true,
	"laytrans" => true,
	"layalpha" => true,
	];

var layerTransitionParam = %[
	"time" => true,
	"color" => true,
	"rule" => true,
	"endtime" => true,
	"endcolor" => true,
	"endrule" => true,
	"endtype" => true
	];

var actionParam = %[
	"time" => true,
	"delay" => true,
	"nowait" => true,
	"start" => true,
	"startx" => true,
	"starty" => true,
	"x" => true,
    "y" => true,
    "toptime" => true,
	"vibration" => true,
    "waittime" => true,
    "cycle" => true,
    "distance" => true,
    "falltime" => true,
    "zoom" => true,
    "angvel" => true,
    "angle" => true,
    "showtime" => true,
    "hidetime" => true,
    "intime" => true,
    "outtime" => true,
    "opacity" => true,
	"min" => true,
	"max" => true,
	"value" => true,
	"ontime" => true,
    "offtime" => true,
    "handler" => true,
    "loop" => true,
    ];

KAGLoadScript('EnvBase.tjs');
KAGLoadScript('EnvImage.tjs');
KAGLoadScript('EnvLayer.tjs');
KAGLoadScript('EnvBackLayer.tjs');
KAGLoadScript('EnvStageLayer.tjs');
KAGLoadScript('EnvEventLayer.tjs');
KAGLoadScript('EnvLevelLayer.tjs');
KAGLoadScript('EnvSimpleLayer.tjs');
KAGLoadScript('EnvCharacter.tjs');
KAGLoadScript('EnvBGM.tjs');
KAGLoadScript('EnvSE.tjs');
KAGLoadScript('Environment.tjs');
KAGLoadScript('ScenePlayer.tjs');

kag.addPlugin(kag.scenePlayer = new ScenePlayer(kag));
kag.tagHandlers["sceneinit"]  = kag.scenePlayer.sceneinit;
kag.tagHandlers["sceneopt"]   = kag.scenePlayer.sceneopt;
kag.tagHandlers["scenemacro"] = kag.scenePlayer.scenemacro;
kag.tagHandlers["scenestart"] = kag.scenePlayer.scenestart;
kag.tagHandlers["scenemain"]  = kag.scenePlayer.scenemain;

property sceneExecDialog { getter() { KAGLoadScript("SceneExecDialog.tjs"); return global.sceneExecDialog; } };

var psfolder = "../../PSVersion/DataMake/";

// デバッグメニューに登録
if (kag.debugMenu !== void && kag.debugMenu.visible) {
	kag.debugMenu.insert(new MenuItem(this, "-"), 0);
	kag.debugMenu.insert(kag.loadSceneMenuItem =
						 new KAGMenuItem(this, "パラメータの変換", 1,
										 function() {
											 kag.scenePlayer.convertParam(psfolder);
										 }), 0);
	kag.debugMenu.insert(kag.loadSceneMenuItem =
						 new KAGMenuItem(this, "シーンの変換（全部）", 1,
										 function() {
											 kag.scenePlayer.convert(psfolder, true);
										 }), 0);

	kag.debugMenu.insert(kag.loadSceneMenuItem =
						 new KAGMenuItem(this, "シーンの変換", 1,
										 function() {
											 kag.scenePlayer.convert(psfolder);
										 }), 0);
	
	kag.debugMenu.insert(kag.loadSceneMenuItem =
						 new KAGMenuItem(this, "シーンの読込み(&L)", 1,
										 function() {sceneExecDialog();}), 0);
}

if (kag.debugLevel >= tkdlSimple) {
	dm("ワールド環境設定完了");
}
