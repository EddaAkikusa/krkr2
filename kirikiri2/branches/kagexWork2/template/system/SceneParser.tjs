var LINEMODE_NONE = 0;
var LINEMODE_PAGE = 1;
var LINEMODE_LINE = 2;
var LINEMODE_VN   = 3;
var LINEMODE_TEX  = 4;
var LINEMODE_FREE = 5;

/**
 * シーン再生用パーサ
 * KAG 形式でかかれたシナリオデータを
 * linemode に応じて改行処理を適切に行って再生用の状態に変換するパーサ
 *
 * ボイスの自動処理機能を持つ
 * - ボイスはあらかじめ一覧リストを準備する必要がある(ボイスのファイル名リストをつくっておく)
 * - キャラクタ毎にボイス用の定義をあらかじめくんでおくこと
 */
class SceneParser extends KAGParser
{
	var lines; // パース結果
	var errors; // エラー結果

    /**
     * @param lineMode
     * 1:行単位で [p]
     * 2:行単位で [l] 手動で [p]
     * 3:行単位で [l] 空行で [p]
     * 4:改行は無視。空行で [p]
     * 5:改行は [r] 。空行で [p]
     */
	var lineMode;    // 改行処理モード
    var crAfterName; // 名前の後に改行をいれるか
    var erAfterPage; // 改ページ直後に画面消去するか
    var autoIndent;  // 「『で自動的にインデントする
	var voiceDefault;  // ボイスデフォルト値

	var voiceMap = %[];      // ボイス状態記録マップ

	var noCrOnce;    // 改行処理を１回なしにする
    var noErOnce;    // 画面消去処理を１回なしにする
    var afterPage;   // 改ページ直後
	var doLine;      // 入力待ち実行指示
    var emptyLine;     // まだ行が空
    var prevEmptyLine; // 前の空行状態

    var nameMode;       // 名前処理モード
    var nameStr;        // 現在の名前
    var nameDisp;       // 現在の表示名
	var nameInfos = []; // 登録済みの名前
	
	// -------------------------------------------------------------

	/**
	 * コンストラクタ
	 */
	function SceneParser() {
		super.KAGParser(...);
	}

	/**
	 * 初期化処理
	 */
	function init() {
		lines = [];
		errors = [];
		(Dictionary.clear incontextof voiceMap)(); 
		noCrOnce = false;
		noErOnce = false;
		afterPage = true;
		emptyLine = true;
		prevEmptyLine = true;
		nameMode  = 0;
		nameInfos.clear();
		voiceBase = "";
	}

	/**
	 * 全情報消去
	 */
	function clear() {
		super.clear();
		init();
	}
	
	// -------------------------------------------------------------

	/**
	 * タグの追加
	 */
	function enqueueTag(tag) {
		lines.add(tag);
	}
	
	/**
	 * タグの追加（コピー処理する）
	 */
	function addTag(name, elm) {
        var e = %[];
        if (elm !== void) {
            (Dictionary.assign incontextof e)(elm, false);
        }
        e.tagname = name if name !== void;
		//dm("タグ追加:" + e.tagname);
		lines.add(e);
    }

	// ------------------------------------------------

	/**
	 * エラー
	 * @param type 種類
	 * @param msg メッセージ
	 */
	function error(type, msg) {
		errors.add(curStorage + ":" + curLine + ":(" + type + ") " + msg);
	}

	// ------------------------------------------------

	var voiceInfos; // ボイス展開用情報
	var voiceBase;  // ボイス展開時のベース値
	
	/**
	 * 指定キャラの現在のボイス情報を返す
	 * @param name キャラ名
	 * @return ボイスファイル名
	 */
	function getCurrentVoice(name) {
		//dm("ボイス情報取得:" + name);
		var info = voiceMap[name];
		if (info == void) {
			if (voiceDefault !== void) {
				info = %[];
				voiceMap[name] = info;
				info.voice = voiceDefault;
			}
		}					
		var voice;
		if (info !== void) {
			if (info.strVoice !== void) {
				// 文字列指定
				dm("文字列指定:" + info.strVoice);
				if (info.strVoice != "ignore") {
					voice = info.strVoice;
				}
				info.strVoice = void;
			} else if (info.voice !== void) {
				voice = info.voice;
				info.incVoice = true;
			}
			if (info.incVoice) {
				if (info.voice >= 0) {
					info.voice++;
				}
				info.incVoice = void;
			}
			if (typeof voice == "Integer") {
				// 数値指定の場合は規定に従って変換
				var vinfo = voiceInfos[name];
				var voiceFile = vinfo !== void ? vinfo.filename : void;
				if (voiceFile !== void) {
					voice = voiceFile.sprintf(voiceBase, voice);
				}
			}
		}
		return voice;
	}

	/**
	 * 名前のエントリ。これで登録されたものは、
	 * テキスト表示または playvoice 命令でボイス再生されます。
	 * @param name 名前
	 * @param disp 表示名
	 */
	function entryName(name, disp) {
		var info = %[];
		info.name = name;
		info.disp = disp if disp !== void;
		// ボイス情報の展開
		var voice = getCurrentVoice(name);
		if (voice !== void && voice != "") {
			if (isExistVoiceName(voice)) {
				info.voice = voice;
				// デフォルト名以外用の別ボイスがある場合
				if (isExistVoiceName(voice + "N")) {
					info.voicen = voice + "N";
				}
			} else {
				error("voice", "ボイスファイルがありません:" + voice);
			}
		}
		nameInfos.add(info);
	}
	
	// 正規表現
	var reNumber = new RegExp("^[0-9][0-9]*$");
	// ボイスコマンド扱い
	var voiceCmds = %[ tagname:true, replace:true, once:true, entry:true ];
	
	/**
	 * ボイス番号指定のパース
	 */
	function parseVoice(elm) {
		var names = [];
		names.assign(elm);
		for (var i=0;i<names.count;i+=2) {
			var name  = names[i];
			var value = names[i+1];
			if (voiceCmds[name] !== void) {
				continue;
			}
			var info = voiceMap[name];
			if (info == void) {
				info = %[];
				voiceMap[name] = info;
			}
			if (value == "clear") {
				delete info.strVoice;
				delete info.voice;
				delete info.incVoice;
			} else if (value == "ignore") {
				info.strVoice = "ignore";
			} else if (reNumber.test(value)) {
				// 数値指定の場合
				if (elm.once || elm.replace) {
					info.strVoice = +value;
				} else {
					info.voice = +value;
				}
			} else {
				info.strVoice = value;
			}
			info.incVoice = elm.replace;
			// 再生指定
			if (elm.entry) {
				entryName(name);
			}
		}
	}

	/**
	 * 強制再生処理
	 */
	function parsePlayvoice(elm) {
		if (nameInfos.count > 0) {
			for (var i=0;i<nameInfos.count;i++) {
				var info = nameInfos[i];
				if (info.voice !== void) {
					addTag("entryvoice", info);
				}
			}
			addTag("playvoice");
			nameInfos.clear();
		}
	}
	
	/**
	 * テキストのパース処理
	 */
    function parseCh(elm) {
		// 名前表示専用処理
		//【キャラクタ名/表示名】を検出して名前表示処理を実行する
		if (nameMode > 0) {
			// 既に名前表示ロジックに入ってる
			// ここでは emptyLine の状態はありえない
			if (elm.text == "】") {
				nameMode = 0;
				entryName(nameStr, nameDisp);
				return;
			} else {
				if (nameMode == 1) {
					if (elm.text == "/") {
						nameMode = 2;
						return;
					} else {
						nameStr += elm.text;
                    }
                } else {
                    nameDisp += elm.text;
                }
            }
            return;

		} else if (emptyLine) {

			// 行頭

			// 改行指示がある
			if (doLine) {
				parseL();
				doLine = false;
			}

			if (elm.text == "【") {
				nameMode = 1;
				nameStr  = "";
				nameDisp = "";
				return;
            } else {
				nameMode = 0;
				// 名前指定がない場合はパラメータなしで名前処理を呼び出す
				if (nameInfos.count == 0 && (lineMode < LINEMODE_VN || prevEmptyLine)) {
					nameInfos.add(%[]);
				}
			}
		}

		// 名前表示の展開
		if (nameInfos.count > 0) {
			addTag("msgon");
			var i;
			for (i=0;i<nameInfos.count-1;i++) {
				var info = nameInfos[i];
				if (info.voice !== void) {
					addTag("entryvoice", info);
				}
			}
			var info = nameInfos[i];
			addTag("dispname", info);
		}
		
		// ラインモード処理
        var erflag;
		
        // テキストクリア処理
		switch (lineMode) {
        case LINEMODE_PAGE:
			if (emptyLine) {
				erflag = true;
            }
            break;
        case LINEMODE_LINE:
        case LINEMODE_VN:
        case LINEMODE_FREE:
			if (afterPage) {
                afterPage = false;
                if (emptyLine) {
                    erflag = true;
                }
			} else {
				if (emptyLine) {
					addTag("r");
				}
            }
            break;
        case LINEMODE_TEX:
            if (afterPage) {
                afterPage = false;
                erflag = true;
            }
            break;
        }
		if (erflag && !erAfterPage) {
			addTag("er");
        }
		
		// 文字登録
		addTag("ch", elm);
		emptyLine = false;

		// 自動インデント処理
		if (autoIndent && nameInfos.count > 0 && (elm.text == "「" || elm.text == "『")) {
			addTag("indent");
		}
		nameInfos.clear();
        return;
    };

	/**
	 * 改行のパース処理
	 */
	function parseR(elm) {

		if (!elm.eol) {
			addTag("r", elm);
			return;
		}

		// 改行効果を一度だけ無視させる
		if (noCrOnce) {
			noCrOnce = false;
			prevEmptyLine = emptyLine;
            emptyLine = true;
            return;
        }

		nameMode = 0;
		if (crAfterName && nameInfos.count > 0) {
			return;
		}
		switch (lineMode) {
		case LINEMODE_PAGE:
			//dm("page:改行");
			if (emptyLine) {
				prevEmptyLine = emptyLine;
				return; // 空行は無視する
			} else {
				// 名前の直後の改行は無視する
				prevEmptyLine = emptyLine;
				parseP(elm);
				return;
			}
            break;
		case LINEMODE_LINE:
			//dm("line:改行");
            if (emptyLine) {
				prevEmptyLine = emptyLine;
				return; // 空行は無視する
			} else {
				// 名前の直後の改行は無視する
				prevEmptyLine = emptyLine;
				emptyLine = true;
				parseL();
				return;
			}
			break;
        case LINEMODE_VN:
            //dm("vn:改行");
            if (emptyLine) {
                if (!prevEmptyLine) {
                    // 最初の空行で改ページ
					doLine = false;
					prevEmptyLine = emptyLine;
					parseP(elm);
					return;
                } else {
                    // そうでない空行は無視する
                    prevEmptyLine = emptyLine;
                    return;
                }
            } else {
                // 名前の直後の改行は無視する
				prevEmptyLine = emptyLine;
				emptyLine = true;
				doLine = true;
				return;
            }
            break;
		case LINEMODE_TEX:
		case LINEMODE_FREE:
			//dm("tex/free:改行");
            if (emptyLine) {
                if (!prevEmptyLine) {
                    // 最初の空行で改ページ
                    prevEmptyLine = emptyLine;
					parseP(elm);
					return;
                } else {
                    // そうでない空行は無視する
                    prevEmptyLine = emptyLine;
					return;
                }
            } else {
				prevEmptyLine = emptyLine;
				emptyLine = true;
				return;
            }
		}
		return;
	}

	function parseL() {
		addTag("l", %[voicewait:true]);
		addTag("afterline");
	}
	
	/**
	 * p タグの展開
	 */
    function parseP(elm) {
		addTag("p", elm);
		// 自動インデント解除
		if (autoIndent) {
			addTag("endindent");
		}
		// ページ終了後に呼ばれるタグ
		addTag("afterpage");
		// ページ待ち後に消去を強制投入
		if (erAfterPage) {
			if (!noErOnce) {
				addTag("er");
			}
			noErOnce = false;
		}
		afterPage = true;
		emptyLine = true;
    }

	var extractTags = %[
	ch:parseCh incontextof this,
	r:parseR incontextof this,
	voice:parseVoice incontextof this,
	voicebase: function(elm) { voiceBase = elm.base; return 0; } incontextof this,
	playvoice: parsePlayvoice incontextof this,
	p:parseP incontextof this,
    nor: function(elm) { noCrOnce = true; return 0; } incontextof this,
    noer: function(elm) { noErOnce = true; return 0; } incontextof this,
		];

	/**
	 * パース用オプション設定
	 * @param elm 基本パラメータ
	 * パラメータ
	 * lineMode    行モード指定（必須）
	 * erAfterPage ページの直後に画面消去
	 * crAfterName 名前の後の改行を無視
	 * autoIndent  "「" による自動インデントを有効にする
	 * voice       ボイスカウントの初期値
	 */
	function setOption(elm) {

		if (elm.lineMode == "page") {
			lineMode = LINEMODE_PAGE;
		} else if (elm.lineMode == "line") {
			lineMode = LINEMODE_LINE;
		} else if (elm.lineMode == "vn") {
			lineMode = LINEMODE_VN;
		} else if (elm.lineMode == "tex") {
			lineMode = LINEMODE_TEX;
		} else if (elm.lineMode == "free") {
			lineMode = LINEMODE_FREE;
		} else {
			lineMode     = +elm.linemode;
		}
		erAfterPage  = elm.erafterpage;
		crAfterName  = elm.craftername;
		autoIndent   = elm.autoindent;
		voiceDefault = +elm.voice if elm.voice !== void;
		//dm("lineMode:" + lineMode);
		//dm("erAfterPage:" + erAfterPage);
		//dm("crAfterName:" + crAfterName);
		//dm("autoIndent:"  + autoIndent);
		//dm("voiceDefault:" + voiceDefault);
	}

	/**
	 * マクロ用のパース実行
	 * @param storage 対象ファイル
	 */
	function parseMacro(storage) {
		dm("シーン用のマクロをパース:" + storage);
		ignoreCR  = true;
		loadScenario(storage);
		while (getNextTag() !== void) {} // 次のタグを得る
	}
	
	/**
	 * 全パース処理実行
	 * @param storage 対象ファイル
	 */
	function parse(storage, voiceInfos, voiceBase) {
		init();
		this.voiceInfos = voiceInfos;
		if (voiceBase !== void) {
			this.voiceBase = voiceBase;
		}
		ignoreCR = false;
		loadScenario(storage);
		var runLine = 0;
		var obj;
		while ((obj = getNextTag()) !== void) { // 次のタグを得る
			if (runLine !== curLine) {
				enqueueTag(%[tagname:"line", line:curLine, lineStr:curLineStr]);
				runLine = curLine;
			}
			var func = extractTags[obj.tagname];
			if (func !== void) {
				func(obj);
			} else {
				// XXX 利用可能なタグかチェックしたほうがいいかな？
				addTag(void, obj);
			}
		}
@if(false)
		for (var i=0;i<lines.count;i++) {
			if (lines[i].tagname == "line") {
				dm("パース結果:" + lines[i].tagname + ":" + lines[i].line);
			} else if (lines[i].tagname == "label") {
				dm("パース結果:" + lines[i].tagname + ":" + lines[i].label);
			} else {
				dm("パース結果:" + lines[i].tagname);
			}
		}
@endif
		return lines;
	}

	/**
	 * ラベル通過
	 */
	function onLabel(label, page) {
		//dm("ラベル登録:" + label + ":" + curLine);
		enqueueTag(%[tagname:"label", label:label, page:page, line:curLine]);
		return true;
	}
}
