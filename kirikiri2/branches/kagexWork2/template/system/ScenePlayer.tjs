/**
 * シーン再生ロジック
 * 共通コード
 */
class ScenePlayer extends BasicPlayer
{
	var lines = [];    // パース結果
	var pendings = []; // 割り込み処理

	/**
	 * タグ割り込み処理
	 */
	function addTag(name, elm) {
		var e = %[];
		if (elm !== void) {
			(Dictionary.assign incontextof e)(elm, false);
		}
		e.tagname = name if name !== void;
		pendings.add(e);
    }
	
	var handlers;      // 処理ハンドラ群
	
	// 実行情報
	var curStorage;        // 実行中のシナリオ
	var cur;               // 実行ポイント
	var curLine;           // 通過中の行番号
	var targetLine;        // ロード処理ターゲット行
	var nextScene;         // 次のシーン

	// 選択処理通過記録
	var branches = %[];
	
	// Conductor - シナリオ進行処理
	/*const*/ var mStop = 0; // 停止
	/*const*/ var mRun  = 1; // 動作中
	/*const*/ var mWait = 2; // 待ち

	var status = mStop;   // 実行状態
	var waitUntil = %[];  // 待ち状態記録用
	var lastTagName = ''; // 直前のタグ名

	var nowTick = 0;  // 現在の実行時間
	var nextTick;     // 次の実行時間
	var timeoutTick;  // 時間待ち用
	
	/**
	 * コンストラクタ
	 */
	function ScenePlayer() {
		super.BasicPlayer();
		handlers = getHandlers();
		status = mStop;
    }

	/**
	 * ファイナライザ
	 */
	function finalize()	{
		super.finalize();
	}

	/**
	 * 情報クリア
	 */
	function clear() {
		status = mStop;
		lastTagName = "";
		(Dictionary.clear incontextof branches)();
		(Dictionary.clear incontextof waitUntil)();
		curStorage = void;
		cur = 0;
		curLine = 0;
		targetLine = void;
		nextScene = void;
	}

	// ------------------------------------------------------------
	
	/**
	 * 待ち
	 * until = trigger で用いるシグナル名とコールバック関数の
	 * 辞書配列
	 */
	function wait(until) {
		status = mWait;
		(Dictionary.assign incontextof waitUntil)(until);
	}

	/**
	 * タイムアウトつきの待ち
	 * タイムアウト時には 'timeout' がトリガされるので
	 * ハンドラを定義すること。
	 */
	function waitWithTimeOut(until, timeout) {
		wait(until);
		if(timeout == 0) timeout = 1; // timeout が 0 の場合は 1 に
		timeoutTick = nowTick + timeout;
	}

	/**
	 * 待ち解除トリガ
	 *
	 * waitUntil 内にシグナル名 name が存在すれば、実行再開、
	 * 同時に waitUntil に登録されたメソッド(リスタートハンドラ)を呼ぶ
	 * シグナル名に _arg がついたものが waitUntil 内にあれば、
	 * それを引数としてハンドラに渡す
	 * waitUntil はクリアされる
	 */
	function trigger(name) {
		if(status != mWait) return false;
		var func = waitUntil[name];
		if(func !== void) {
			var arg = waitUntil[name + '_arg'];
			if(arg !== void) func(arg); else func();
			(Dictionary.clear incontextof waitUntil)();
			status = mRun;
			return true;
		} else {
			return false;
		}
	}

	// ------------------------------------------------------------
	
	/**
	 * タグの処理
	 */
	function onTag(elm) {
		var tagname = elm.tagname;
		//dm("シーンタグ:" + tagname);
		var handler = handlers[tagname];
		if (handler !== void) {
			var ret = handler(elm);
			lastTagName = tagname;
			return ret;
		}
		// 無効なタグ
		var ret = env.unknown(tagname, elm);
		if (ret === void) {
			var msg = "タグ/マクロ \"" + tagname + "\" は存在しません";
			errorCmd(msg);
			return 0;
			//throw new Exception(msg);
		}
		return ret;
	}

	// --------------------------------------------------------------

	/**
	 * 実行開始
	 * @param storage 開始シナリオ
	 * @param option パース用オプション
	 */
	function run(storage) {
		clear();
		curStorage = storage;
		lines = getScene(curStorage);
		status = mRun;
	}
	
	/**
	 * 状態保存
	 */
	function save(dic) {
		dic.status = status;
		if (status != mStop) {
			dic.storage = curStorage;
			dic.branches = %[];
			(Dictionary.assign incontextof dic.branches)(branches);
			if (curLine > 0) {
				dic.targetLine = curLine;
			}
		}
		return dic;
	}

	/**
	 * 状態復帰
	 * パラメータ: storage
	 */
	function load(dic) {
		clear();
		if (dic.status != mStop) {
			curStorage = dic.storage;
			if (dic.branches !== void) {
				(Dictionary.assign incontextof branches)(dic.branches);
			}
			lines = getScene(curStorage);
			targetLine = dic.targetLine;
			status = mRun;
		}
	}

	/**
	 * メインロジック
	 * @return 0:終了 1:実行 2:イベント待ち
	 */
	function main(diff)	{

		nowTick += diff;

		// タイムアウト処理
		if (timeoutTick !== void) {
			timeoutTick -= diff;
			if (timeoutTick < 0) {
				trigger("timeout");
				timeoutTick = void;
			}
		}

		//dm("scene メインロジック:" + nowTick + ":" + nextTick);

		
		// 時間待ち処理
		if (nextTick !== void && nextTick < nowTick) {
			return -4;
		}
		nextTick = void;

		// 停止または待ち
		if (status == mStop) {
			return -1;
		} else  if (status == mWait) {
			return -4;
		}

		var obj;
		for(;;)	{
			if (pendings.count > 0) {
				// 後回しにされたタグがある場合
				obj = pendings[0];
				pendings.erase(0);
			} else {
				obj = lines[cur++];
			}
			
			if(obj === void) {
				// シナリオ終了
				var next = nextScene !== void ? nextScene : getNextScene(curStorage);
				if (next !== void) {
					clear();
					lines = getScene(next);
					status = mRun;
					continue;
				} else {
					status = mStop;
					return -1;
				}
			} else if (obj.tagname == "line") {
				if (curLine != obj.line) {
					curLine    = obj.line;
					//dm("%06d:%s %s".sprintf(curLine, curStorage, obj.lineStr));
				}
				continue;
			} else if (obj.tagname == "label") {
				continue;
			} else {
				// 実行時判定される cond
				if (obj.condex !== void) {
					if (!Scripts.eval(obj.condex)) {
						continue;
					}
					delete obj.condex;
				}
				
				// onTag を呼ぶ
				var step = onTag(obj);
				if(step === void) {
					throw new Exception("onTag が void を返しました (" + obj.tagname + ")"
										"( おそらくタグハンドラの戻り値を返し忘れた )");
				}
				step = int step; // step を数値に
				//dm("タグ戻り値:" + step);
				
				if (step == 0) {
					// ウェイトを掛けずに次へ
					continue;
				}
				else if(step < 0) {
					switch(step) {
					case -5: // いったんイベントを処理(現在のタグは後回し)
						pendings.insert(0, obj);
						return step;
					case -4: // いったんイベントを処理
						return step;
					case -3: // 後回ししてブレーク
						pendings.insert(0, obj);
						return step;
					case -2: // ブレーク
						return step;
					case -1: // シナリオ終了
						status = mStop;
						return step;
					}
				} else {
					// 時間待ち
					//nextTick = nowTick + step;
					return step;
				}
			}
		}
	}

	// ------------------------------------------------------------------

	function getHandlers()
	{
		return %[ // 辞書配列オブジェクト

	//----------------------------------------- タグハンドラ群(各種機能) --

    ch : tag_ch,
	r : tag_r,
	ruby : tag_ruby,
	font : tag_font,
    deffont : tag_deffont,
	resetfont : tag_resetfont,
	style : tag_style,
	defstyle : tag_defstyle,
	l : tag_l,
	p : tag_p,
	er : tag_er,
	indent : tag_indent,
	endindent : tag_endindent,
	delay : tag_delay,
	cancelskip : tag_cancelskip,
	resetwait : tag_resetwait,
	wait : tag_wait,
    syncmsg : tag_syncmsg,
	backlay : tag_backlay,
	forelay : tag_forelay,
	trans : tag_trans,
	wt : tag_wt,
    action : tag_action,
	stopaction : tag_stopaction,
	wact : tag_wact,
	eval : tag_eval,
	clearsysvar : tag_clearsysvar,
	clearvar : tag_clearvar,
	clearplaytime : tag_clearplaytime,
	waittrig : tag_waittrig,
    beginskip : tag_beginskip,
    endskip : tag_endskip,
	ltbegin : tag_ltbegin,
	ltend : tag_ltend,

    msgwin : tag_msgwin,
				  
	//----------------------------------------- タグハンドラ群(選択肢分岐) --
				  
    seladd : function(elm)
    {
		return addSelect(elm);
	} incontextof this,

    select : function(elm)
    {
		return doSelect(elm);
	} incontextof this,

	seldone : function(elm)
	{
		return doneSelect(elm);
	} incontextof this,

	//----------------------------------------- タグハンドラ群(シナリオ内分岐) --

    bradd : function(elm)
    {
		return addBranch(elm);
	} incontextof this,

    branch : function(elm)
    {
		return doBranch(elm);
	} incontextof this,

    brdone : function(elm)
    {
		return doneBranch(elm);
	} incontextof this,

	//----------------------------------------- タグハンドラ群(シーン間分岐処理) --

	next : function(elm)
	{
		nextScene = elm.storage;
		return 0;
	} incontextof this,
				  
	//----------------------------------------------- 環境系機能 --

	env : env.tagfunc,
    allchar : env.allchar,
    alllayer : env.alllayer,
    allse : env.allse,

	init       : env.initCmd,
	begintrans : env.beginTrans,
    endtrans   : env.endTrans,
    newlay     : env.newLayer,
    newlayer   : env.newLayer,
    dellay     : env.delLayer,
    dellayer   : env.delLayer,
    newchar    : env.newCharacter,
    delchar    : env.delCharacter,

    msgoff : env.msgoff,
    msgon  : env.msgon,

    dispname      : env.dispname,
    dispnameVoice : env.dispnameVoice,
    afterpage     : env.afterpage,
    afterline     : env.afterline,
				  ];
	}

};
