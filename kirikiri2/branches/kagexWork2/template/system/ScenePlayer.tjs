/**
 * シーン再生ロジック
 * 共通コード
 */
class ScenePlayer extends BasicPlayer
{
	var lines = [];    // パース結果
	var pendings = []; // 割り込み処理

	/**
	 * タグ割り込み処理
	 */
	function addTag(name, elm) {
		var e = %[];
		if (elm !== void) {
			(Dictionary.assign incontextof e)(elm, false);
		}
		e.tagname = name if name !== void;
		pendings.add(e);
    }
	
	/**
	 * タグ割り込み処理
	 */
	function insertTag(name, elm) {
		var e = %[];
		if (elm !== void) {
			(Dictionary.assign incontextof e)(elm, false);
		}
		e.tagname = name if name !== void;
		pendings.insert(0,e);
    }

	var handlers;      // 処理ハンドラ群
	
	// 実行情報
	var curStorage;        // 実行中のシナリオ
	var cur;               // 実行ポイント
	var curLine;           // 通過中の行番号
	var targetLine;        // ロード処理ターゲット行
	var nextScene;         // 次のシーン
	var currentText; // 現在表示対象のテキスト
	var saveFlag;

	// 選択処理通過記録
	var branches = %[];

	/**
	 * ジャンプ中か
	 */
	function isJump() {
		return curLine < targetLine;
	}
	
	// Conductor - シナリオ進行処理
	/*const*/ var mStop = 0; // 停止
	/*const*/ var mRun  = 1; // 動作中
	/*const*/ var mWait = 2; // 待ち

	var status = mStop;   // 実行状態
	var waitUntil = %[];  // 待ち状態記録用
	var lastTagName = ''; // 直前のタグ名

	var nowTick = 0;  // 現在の実行時間
	var nextTick;     // 次の実行時間
	var timeoutTick;  // 時間待ち用
	
	/**
	 * コンストラクタ
	 */
	function ScenePlayer() {
		super.BasicPlayer();
		handlers = getHandlers();
		status = mStop;
		currentText = "";
    }

	/**
	 * ファイナライザ
	 */
	function finalize()	{
		super.finalize();
	}

	/**
	 * 情報クリア
	 */
	function clear() {
		clearInfo();
		tag_init(null);
		env.syncAll();
		super.clear();
	}

	function clearInfo() {
		lastTagName = "";
		(Dictionary.clear incontextof branches)();
		curStorage = void;
		cur = 0;
		curLine = 0;
		targetLine = void;
		nextScene = void;
		saveFlag = false;
	}

	// ------------------------------------------------------------
	
	/**
	 * 待ち
	 * until = trigger で用いるシグナル名とコールバック関数の
	 * 辞書配列
	 */
	function wait(until) {
		status = mWait;
		(Dictionary.assign incontextof waitUntil)(until);
	}

	/**
	 * タイムアウトつきの待ち
	 * タイムアウト時には 'timeout' がトリガされるので
	 * ハンドラを定義すること。
	 */
	function waitWithTimeOut(until, timeout) {
		wait(until);
		if(timeout == 0) timeout = 1; // timeout が 0 の場合は 1 に
		timeoutTick = nowTick + timeout;
	}

	/**
	 * 待ち解除トリガ
	 *
	 * waitUntil 内にシグナル名 name が存在すれば、実行再開、
	 * 同時に waitUntil に登録されたメソッド(リスタートハンドラ)を呼ぶ
	 * シグナル名に _arg がついたものが waitUntil 内にあれば、
	 * それを引数としてハンドラに渡す
	 * waitUntil はクリアされる
	 */
	function trigger(name) {
		if(status != mWait) return false;
		var func = waitUntil[name];
		if(func !== void) {
			var arg = waitUntil[name + '_arg'];
			if(arg !== void) func(arg); else func();
			(Dictionary.clear incontextof waitUntil)();
			status = mRun;
			return true;
		} else {
			return false;
		}
	}

	// ------------------------------------------------------------
	
	/**
	 * タグの処理
	 */
	function onTag(elm) {
		var tagname = elm.tagname;
		//dm("シーンタグ:" + tagname);
		var handler = handlers[tagname];
		if (handler !== void) {
			var ret = handler(elm);
			lastTagName = tagname;
			return ret;
		}
		// 無効なタグ
		var ret = env.unknown(tagname, elm);
		if (ret === void) {
			var msg = "タグ/マクロ \"" + tagname + "\" は存在しません";
			errorCmd(msg);
			return 0;
			//throw new Exception(msg);
		}
		return ret;
	}

	// --------------------------------------------------------------

	/**
	 * 実行開始
	 * @param storage 開始シナリオ
	 * @param option パース用オプション
	 */
	function run(storage) {
		clearInfo();
		curStorage = storage;
		lines = getScene(curStorage);
		currentText = "";
		status = mRun;
	}

	var saveDic;

	/**
	 * 状態保存
	 */
	function save(dic) {
		dic.status = status;
		if (status != mStop) {
			dic.storage  = curStorage;
			dic.branches = %[];
			(Dictionary.assign incontextof dic.branches)(branches);
			if (curLine > 0) {
				dic.targetLine = curLine;
			}
		}
		return dic;
	}

	/**
	 * 状態復帰
	 * パラメータ: storage
	 */
	function load(dic) {
		dm("ロード実行開始");
		if (env.event !== void && env.event.targetLayer !== void) {
			dm("ロード前のtargetLayerの状態:" + env.event.targetLayer + ":" + (isvalid env.event.targetLayer ? "1" : "0"));
		}
		clearInfo();
		if (dic.status != mStop) {
			curStorage = dic.storage;
			if (dic.branches !== void) {
				(Dictionary.assign incontextof branches)(dic.branches);
			}
			lines = getScene(curStorage);
			targetLine = dic.targetLine;
			status = mRun;
			currentText = "";
		}
	}

	/**
	 * 指定ラベルまで移動
	 */
	function goToLabel(label) {
		var newcur = 0;
		var obj;
		while ((obj = lines[newcur++]) !== void) {
			if (obj.tagname == "label" && obj.label == label) {
				cur = newcur;
				return;
			}
		}
		throw new Exception("ラベル" + label + "がみつかりません");
	}

	/**
	 * メインロジック
	 * @return 0:終了 1:実行 2:イベント待ち
	 */
	function main(diff)	{

		nowTick += diff;

		// タイムアウト処理
		if (timeoutTick !== void) {
			timeoutTick -= diff;
			if (timeoutTick < 0) {
				trigger("timeout");
				timeoutTick = void;
			}
		}

		//dm("scene メインロジック:" + nowTick + ":" + nextTick);

		
		// 時間待ち処理
		if (nextTick !== void && nextTick < nowTick) {
			return -4;
		}
		nextTick = void;

		// 停止または待ち
		if (status == mStop) {
			return -1;
		} else  if (status == mWait) {
			return -4;
		}

		var obj;
		for(;;)	{
			if (pendings.count > 0) {
				// 後回しにされたタグがある場合
				obj = pendings[0];
				pendings.erase(0);
			} else {
				if (currentText.length > 0) {
					if (isSkip()) {
						obj = %[tagname:"ch2", text:currentText];
						currentText = "";
					} else {
						var ch = currentText.substring(0,1);
						currentText = currentText.substring(1);
						obj = %[tagname:"ch2", text:ch];
					}
				} else {
					obj = lines[cur++];
				}
			}
			
			if (obj === void) {
				// シナリオ終了
				var next = nextScene !== void ? nextScene : getNextScene(curStorage);
				if (next !== void) {
					clearInfo();
					lines = getScene(next);
					status = mRun;
					continue;
				} else {
					status = mStop;
					return -1;
				}
			} else if (obj.tagname == "begintrans") {
				//dm("トランジションを処理");
				while ((obj = lines[cur++]) !== void && obj.tagname != "endtrans") {
					if (obj.tagname == "begintrans") {
						throw new Exception("begintrans は入れ子にできません");
					}
					pendings.add(obj);
				}
				if (obj === void) {
					throw new Exception("begintrans に対応する endtrans がありません");
				}
				if (!isJump()) {
					var trans = void;
					var names = [];
					names.assign(obj);
					for (var i=0;i<names.count;i+=2) {
						var cmd   = names[i];
						var param = names[i+1];
						if (cmd == "tagname") {
							// ignore
						} else if (cmd == "trans") {
							var tr = getTrans(param, obj);
							if (tr !== void) {
								trans = tr;
							}
						} else if (cmd == "fade") {
							var time = +param;
							trans = %[ "method" => "crossfade",
									   "children" => true,
									   "time" => time > 1 ? time : env.fadeValue];
						} else {
							var tr = getTrans(cmd, obj);
							if (tr !== void) {
								trans = tr;
							}
						}
					}
					if (trans !== void && trans.msgoff) {
						insertTag("msgoff");
					}
					if (trans !== void && trans.method == "layer") {
						insertTag("_beginlt", trans);
						addTag("_endlt", %[wait:trans.transwait, time:trans.endtime, color:trans.endcolor, type:trans.endtype, rule:trans.endrule]);
					} else {
						transMode = 1;
						insertTag("_begintrans");
						beginTransition(trans);
						addTag("_endtrans");
					}
				}
				continue;
			} else if (obj.tagname == "line") {
				if (curLine != obj.line) {
					curLine    = obj.line;
					if (saveFlag) {
						doSave();
						saveFlag = false;
					}
					if (targetLine !== void && curLine >= targetLine) {
						targetLine = void;
						env.syncAll();
					}
				}
				continue;
			} else if (obj.tagname == "label") {
				continue;
			} else if (obj.tagname == "ch") {
				currentText = obj.text;
				continue;
			} else {
				// 実行時判定される cond
				if (obj.condex !== void) {
					if (!Scripts.eval(obj.condex)) {
						continue;
					}
					delete obj.condex;
				} else if (obj.if !== void) {
					dm("if:" + obj.if);
					if (!Scripts.eval(obj.if)) {
						continue;
					}
					delete obj.if;
				}

				var	step = onTag(obj);
				if(step === void) {
					throw new Exception("onTag が void を返しました (" + obj.tagname + ")"
										"( おそらくタグハンドラの戻り値を返し忘れた )");
				}
				step = int step; // step を数値に
				//dm("タグ戻り値:" + step);
				
				if (step == 0) {
					// ウェイトを掛けずに次へ
					continue;
				}
				else if(step < 0) {
					switch(step) {
					case -5: // いったんイベントを処理(現在のタグは後回し)
						pendings.insert(0, obj);
						return step;
					case -4: // いったんイベントを処理
						return step;
					case -3: // 後回ししてブレーク
						pendings.insert(0, obj);
						return step;
					case -2: // ブレーク
						return step;
					case -1: // シナリオ終了
						status = mStop;
						return step;
					}
				} else {
					// 時間待ち
					//nextTick = nowTick + step;
					return step;
				}
			}
		}
	}

	// ------------------------------------------------------------------
	// 特殊コマンド
	// ------------------------------------------------------------------

	// トランジションモード
	var transMode;

	/**
	 * 初期化
	 */
	function tag_init(elm) {
		transMode = 0;
		env.initEnv(elm);
		clearTrash();
		return 0;
	}
	
    /**
     * 全体トランジション開始
     */
	function tag_begintrans(elm) {
		backup();
		transMode = 1;
        return 0;
    }

    /**
     * 全体トランジション終了
     */
	function tag_endtrans(elm) {
		transMode = 0;
		return 0;
    }

	/**
	 * レイヤトランジション開始
	 */
	function tag_beginlt(elm) {
		transMode = 2;
		return beginLayerTrans(elm);
	}

	/**
	 * レイヤトランジション終了
	 */
	function tag_endlt(elm) {
		transMode = 0;
		return endLayerTrans(elm);
	}

	// ------------------------------------------------------------------
	
	// 次回再生するボイス情報
	// キー:キャラクタ名
	// 値:ボイス
	var nextvoices = %[];
	var nextvoicecount = 0;

	/**
	 * 次回同時に鳴らすボイスの追加
	 * @param name キャラ名
	 * @param voice  ボイス指定
	 * @param voicen 非デフォルト時ボイス指定
	 */
	function entryNextVoice(name, voice, voicen) {
		if (name !== void && voice !== void) {
			nextvoices[name] = %[voice:voice, voicen:voicen];
			nextvoicecount++;
		}
    }

	/**
	 * 次回鳴らすボイスの情報をクリア
	 */
	function clearNextVoice() {
		(Dictionary.clear incontextof nextvoices)();
		nextvoicecount = 0;
	}

	/**
	 * 複数ボイスを鳴らす
	 * @return 最長のボイス再生時間
     */
	function playVoices(voices) {
		var ret = void;
		if (voices !== void) {
			var names = [];
			names.assign(voices);
			for (var i=0;i<names.count;i+=2) {
				var name = names[i];
				var info = names[i+1];
				var r;
				// デフォルト名の場合の処理
				if (isDefaultName() && info.voicen !== void) {
					r = playVoice(name, info.voicen);
				} else {
					r = playVoice(name, info.voice);
				}
				if (ret === void || r !== void && r > ret) {
					ret = r;
				}
			}
		}
		return ret;
    }
	
	/**
	 * ボイス再生実行
	 */
	function playNextVoice() {
		if (nextvoicecount > 0) {
			var ret = playVoices(nextvoices);
			clearNextVoice();
			return ret;
		}
	}
	
	// ------------------------

	/**
	 * ボイス追加
	 */
	function tag_entryvoice(elm) {
		entryNextVoice(elm.name, elm.voice, elm.voicen);
		return 0;
	}

	/**
	 * ボイス再生
	 */
	function tag_playvoice(elm) {
		playNextVoice();
		return 0;
	}

	/**
	 * ボイス待ち
	 */
	function tag_waitvoice(elm) {
		if (!isJump()) {
			if (elm.name !== void) {
				return waitVoice(elm.name);
			}
		}
		return 0;
	}
	
	/**
	 * 名前表示
	 */
	function tag_dispname(elm) {

		if (voicecut && !voicecutpage) {
			stopAllVoice();
		}

		var dispName = void;
		var faceName = void;
		
		//dm("名前表示ハンドラ");
		if (elm === void || elm.name === void || elm.name == "") {
			
			env.currentNameTarget = void;

		} else {

			var name = elm.name;
			var disp = elm.disp;

			var ch = env.getCharacter(name);
			env.currentNameTarget = ch;

			if (elm.voice !== void) {
				entryNextVoice(name, elm.voice, elm.voicen);
			}

			// 名前の決定
			if (disp !== void && disp != "") {
				dispName = disp;
			} else {
				if (ch !== void && ch.init.nameAlias !== void) {
					dispName = Scripts.eval(ch.init.nameAlias);
					if (dispName === void) {
						dispName = name;
					}
				} else {
					dispName = name;
				}
			}
			
			// 名前加工処理
            if (typeof global.dispNameFilter !== 'undefined') {
				dispName = global.dispNameFilter(dispName);
            }
			
			// 表情判定
			if (env.faceLevelName !== void) {
				if (ch !== void) {
					if (ch.isShowFace()) {
						faceName = ch.getPoseImage(env.faceLevelName);
					}
				} else {
					if (env.envinfo.nameFaces !== void) {
						faceName = env.envinfo.nameFaces[env.envinfo.dispNameFace ? dispName : name];
					}
				}
				// 指定がきまらなかった場合
				if (faceName == void) {
					faceName = env.envinfo.clearFace;
				}
			}
		}

		// 名前表示
		drawName(dispName, faceName, nextvoices);

		// ボイス再生
		if (nextvoicecount > 0) {
			var ret = playNextVoice();
			if (ret > 0) {
				addAutoWait(ret);
			}
		}
		return 0;
	}

	/**
	 * 行待ち終了後に呼び出される処理
	 */
	function tag_afterline(elm) {
		if (voicecut && voicecutpage) {
			stopAllVoice();
		}
		return super.tag_afterline(elm);
    }

    /**
     * ページ処理後に呼び出される処理
     */
	function tag_afterpage(elm) {
		if (voicecut && voicecutpage) {
			stopAllVoice();
		}
		if (!isJump()) {
			saveFlag = true;
		}
		env.currentNameTarget = void;
		return super.tag_afterpage(elm);
    }

	function tag_stopallvoice(elm) {
		stopAllVoice();
		return 0;
	}

	// ------------------------------------------------------------------

	function getHandlers()
	{
		return %[ // 辞書配列オブジェクト

	//----------------------------------------- タグハンドラ群(各種機能) --

    ch2 : tag_ch,
	r : tag_r,
	ruby : tag_ruby,
	font : tag_font,
    deffont : tag_deffont,
	resetfont : tag_resetfont,
	style : tag_style,
	defstyle : tag_defstyle,
	l : tag_l,
	p : tag_p,
	er : tag_er,
	indent : tag_indent,
	endindent : tag_endindent,
	delay : tag_delay,

    cancelskip : tag_cancelskip,
	resetwait : tag_resetwait,
	wait : tag_wait,
	waittrig : tag_waittrig,
    beginskip : tag_beginskip,
    endskip : tag_endskip,
				  
	backlay : tag_backlay,
	forelay : tag_forelay,
	trans : tag_trans,
	wt : tag_wt,
    action : tag_action,
	stopaction : tag_stopaction,
	wact : tag_wact,

	eval : tag_eval,
    set : tag_set,

    msgwin : tag_msgwin,
    msgoff : tag_msgoff,
    msgon  : tag_msgon,
    syncmsg : tag_syncmsg,
    savepoint : function(elm) { return 0; }, // XXX 暫定

	//----------------------------------------- タグハンドラ群(選択肢分岐) --
				  
    seladd : function(elm)
    {
		return addSelect(elm);
	} incontextof this,

    select : function(elm)
    {
		return doSelect(elm);
	} incontextof this,

	seldone : function(elm)
	{
		return doneSelect(elm);
	} incontextof this,

	selend : function(elm)
	{
		return endSelect(elm);
	} incontextof this,

	selopt : function(elm)
	{
		return optSelect(elm);
	} incontextof this,

	//----------------------------------------- タグハンドラ群(シナリオ内分岐) --

    "goto" => function(elm) {
		if (elm.target !== void) {
			goToLabel(elm.target);
		}
		return 0;
	} incontextof this,

	//----------------------------------------- タグハンドラ群(次シナリオ指定) --

	next : function(elm)
	{
		if (elm.storage !== void) {
			if (elm.storage.charAt(0) == '@') {
				nextScene = eval(elm.storage.substring(1));
			} else {
				nextScene = elm.storage;
			}
			cur = lines.count;
		}
		return 0;
	} incontextof this,

    exit : function(elm) {
		cur = lines.count;
		return 0;
	} incontextof this,

	//----------------------------------------------- 環境系機能 --

    env      : env.tagfunc,
    allchar  : env.allchar,
    alllayer : env.alllayer,
    allse    : env.allse,

	init       : tag_init,
	_begintrans : tag_begintrans,
    _endtrans   : tag_endtrans,
    _beginlt    : tag_beginlt,
    _endlt      : tag_endlt,

    newlay     : env.newLayer,
    newlayer   : env.newLayer,
    dellay     : env.delLayer,
    dellayer   : env.delLayer,
    newchar    : env.newCharacter,
    delchar    : env.delCharacter,

    entryvoice    : tag_entryvoice,
    playvoice     : tag_playvoice,
    waitvoice     : tag_waitvoice,
    dispname      : tag_dispname,
    afterpage     : tag_afterpage,
    afterline     : tag_afterline,
    stopallvoice  : tag_stopallvoice,

	//----------------------------------------------- その他 --

	movie : function(elm) { return 0; }
		
		];
	}
};
