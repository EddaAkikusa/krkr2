/**
 * 環境BGMオブジェクト
 */
class KAGEnvBgm extends KAGEnvObject {
	
	var storage;   // 参照しているファイル名
	var volume;    // 音量
	var loop;      // ループ指定
	var start;     // 開始指定
	var pause;     // ポーズ指定

	var transTime; // 変動時間
	var waitFade;  // フェード待ち指定
	var wait;      // 終了待ち指定

	var replay;  // 再生指定
	var refade;  // 音量指定
	var repause;

    /**
     * セーブ処理
     */
    function onStore(f) {
		f.storage = storage;
		f.volume  = volume;
		f.loop    = loop;
		f.start   = start;
		f.pause   = pause;
	}

	function onRestore(f) {
		if (f !== void) {
			storage = f.storage;
			volume  = f.volume;
			loop    = f.loop;
			start   = f.start;
			pause   = f.pause;
			replay  = f.storage !== void;
			transTime = 0;
		}
	}
	
    /**
     * コンストラクタ
     */
    function KAGEnvBgm(env) {
		super.KAGEnvObject(env, "bgm");
    }

    /**
     * 再生処理
     * @param param 再生対象ファイル
     */
    function setPlay(param, elm) {
        if (param !== void) {
			replay = true;
			storage = param;
			volume    = elm.volume !== void ? +elm.volume : 100;
			loop      = elm.loop;
			start     = elm.start;
			transTime = +elm.time if elm.time !== void;
			env.setBGMFlag(param);
        }
    }

    /**
     * 停止処理
     * @param param フェードアウト時間
     */
	function setStop(param, elm) {
		replay = true;
		storage = void;
		transTime = elm.time !== void ? +elm.time : +param;
    }

    /**
     * ポーズ処理
     * @param param フェードアウト時間
     */
	function setPause(param, elm) {
		if (storage !== void) {
			repause = true;
			pause = true;
		}
	}

    /**
	 * 再開
	 */
	function setResume(param, elm) {
		if (storage !== void) {
			repause = true;
			pause = false;
		}
    }

    /**
     * 音量フェード
     * @param param フェード時間
     */
	function setFade(param, elm) {
		refade    = true;
		volume    = param;
		transTime = elm.time !== void ? +elm.time : +param;
    }

    /**
     * 終了まち
     * @param param フェード時間
     */
    function setWait(param, elm) {
        wait = %[];
        (Dictionary.assign incontextof wait)(elm, false);
        if (wait.canskip === void) {
            wait.canskip = true;
        }
    }

    /**
     * 終了まち
     * @param param フェード時間
     */
    function setWaitFade(param, elm) {
        waitFade = %[];
        (Dictionary.assign incontextof waitFade)(elm, false);
        if (waitFade.canskip === void) {
            waitFade.canskip = true;
        }
    }

    var bgmcommands = %[
    tagname : null, 
	storage : setPlay incontextof this,
    play : setPlay incontextof this,
    stop : setStop incontextof this,
    pause : setPause incontextof this,
	resume : setResume incontextof this,
    fade : setFade incontextof this,
    wait : setWait incontextof this,
    waitfade : setWaitFade incontextof this,
    loop : null,
    time : null,
    start : null,
    canskip : null,
        ];

    var doflag;
    
    /**
     * コマンドの実行
     * @param cmd コマンド
     * @param param パラメータ
     * @param elm 他のコマンドも含む全パラメータ
     * @return 実行が行われた場合 true
     */
    function doCommand(cmd, param, elm) {
        var func;
        if ((func = bgmcommands[cmd]) !== void) {
            if (func != null) {
                func(param, elm);
				return true;
            }
			return false;
        }
        // 再生コマンドとみなす
		setPlay(cmd, elm);
        return true;
    }

    /**
     * KAG タグ処理
     * @param elm 引数
     */
	function tagcommand(elm) {
		dm("BGM 用ファンクション呼び出し!");
		wait = void;
		waitFade = void;
		transTime = void;
		var doflag = false;
		var names = [];
		names.assign(elm);
		for (var i=0; i<names.count; i+= 2) {
			if (doCommand(names[i], names[i+1], elm)) {
				doflag = true;
			}
		}
		if (!doflag && elm.tagname != "bgm") {
			setPlay(elm.tagname, elm);
        }
	}

	/**
	 * コマンド同期
	 */
	function sync() {
		var time = isSkip() ? 0 : transTime;
		if (replay) {
			dm("再生状態変更:" + storage);
			if (storage !== void) {
				env.playBGM(time, %[storage:storage, loop:loop, start:start]);
			} else {
				env.stopBGM(time);
			}
			if (pause) {
				env.pauseBGM(0);
			}
			replay = false;
			refade = false;
			repause = false;
		} else if (refade) {
			env.fadeBGM(time, volume);
			refade = false;
		} else if (repause) {
			if (pause) {
				env.pauseBGM(time);
			} else {
				env.resumeBGM(time);
			}
			repause = false;
		}
		if (waitFade !== void) {
			return env.waitBGMFade(waitFade);
		} else  if (wait !== void) {
			return env.waitBGMStop(wait);
		}
        return 0;
    }
};
