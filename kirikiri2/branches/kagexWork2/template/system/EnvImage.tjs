/**
 * 環境用レイヤ
 * ・座標配置調整機能を持つ
 */
class EnvGraphicLayer extends GraphicLayerBase {

	var owner;

	/**
	 * コンストラクタ
	 * @param owner オブジェクト情報をもってる親
	 * @param isfore 表画面か裏画面か
	 */
	function EnvGraphicLayer(owner, isfore) {
		this.owner = owner;
		super.GraphicLayerBase(isfore);
	}

	var _left = 0;
	property left {
		getter() {
			return _left;
		}
		setter(v) {
			_left = +v;
			recalcPosition();
		}
	}
	var _top = 0;
	property top {
		getter() {
			return _top;
		}
		setter(v) {
			_top = +v;
			recalcPosition();
		}
	}

	function setPos(left, top, width, height) {
		//dm("座標設定:" + left + "," + top);
		this.width = width if width !== void; 
		this.height = height if height !== void;
		_left = left;
		_top  = top;
		recalcPosition();
	}
	
	/**
	 * 配置位置調整
	 */
	function recalcPosition() {
		setRealPosition(+left, +top);
	}

	function setRealPosition(left, top) {
		super.left = left;
		super.top  = top;
	}
	
};

/**
 * 環境画像の基底クラス
 */
class EnvImage extends EnvBase {

	// デフォルト情報
	var init;

	var layerOn; //< レイヤが有効になっている
	var doShow;  //< 表示処理実行
	
	/// 表示状態変更
    // BOTH      バストアップ＋フェイス (標準）
    // BU        バストアップ
    // FACE      フェイス
	// SHOW      表示状態（自動選択）
	// CLEAR     消去状態 (標準)
    // INVISIBLE 非表示
	var _disp;
	property disp {
		getter() {
			return _disp;
		}
		setter(v) {
			if (v !== _disp) {
				if (v == SHOW) {
					if (isClear()) {
						if (init !== void && init.noPose !== void) {
							_disp = init.noPose ? FACE : BOTH;
						} else {
							_disp = BOTH;
						}
					}
				} else {
					_disp = v;
				}
				doShow = true;
				if (isShowBU()) {
					layerOn = true;
					redraw = true;
				}
				updateFlag = true;
			}
		}
	}

	// バストアップ表示中
	function isShowBU() {
		return _disp <= BU;
    }

	// フェイス表示中
    function isShowFace() {
        return (_disp == BOTH && env.bothFace)|| _disp == FACE;
    }

	// 表示されているか
	function isShow() {
        return _disp <= FACE;
	}

	// 消去状態か
	function isClear() {
		return _disp == CLEAR;
	}

	// 更新フラグ
	var updateFlag;
    // 再描画指示フラグ
    var redraw;

    /**
     * 時間用最初期化処理
     */
    function setRedraw() {
		if (isShowBU()) {
			redraw = true;
		}
    }
	
	// -----------------------------------------------------------------------
	// レイヤ制御
	// -----------------------------------------------------------------------

    // 種別
	var _type;
	property type {
		getter() {
			return _type;
		}
        setter(v) {
			_type = v;
			updateFlag = true;
        }
    }

	// サイズ指定
	var _width;
	property width {
		getter() {
			return _width;
		}
		setter(v) {
			_width = v;
			updateFlag = true;
		}
	}
	
	var _height;
	property height {
		getter() {
			return _height;
		}
		setter(v) {
			_height = v;
			updateFlag = true;
		}
	}
	
	var cprops;  // プロパティ操作の記録
	// プロパティ指定の結果、アクションによる移動の実行後の結果、などがあらかじめ格納されている

	var props;  // プロパティ操作指定
	var doStopAction; // アクション停止指定
	var actionList; // アクション処理


    // 画像補整指定
    var _grayscale;
    property grayscale {
        getter() {
            if (env.colorall) {
                return env.stage.grayscale;
            } else {
                return _grayscale;
            }
        }
        setter(v) {
            _grayscale = v;
            if (!env.colorall) {
                redraw = true;
            }
        }
    }

    var _rgamma;
    property rgamma {
        getter() {
            if (env.colorall) {
				return env.stage.rgamma;
            } else {
                return _rgamma;
            }
        }
        setter(v) {
            _rgamma = v;
            if (!env.colorall) {
                redraw = true;
            }
        }
    }

    var _ggamma;
    property ggamma {
        getter() {
			if (env.colorall) {
				return env.stage.ggamma;
            } else {
                return _ggamma;
            }
        }
        setter(v) {
            _ggamma = v;
            if (!env.colorall) {
                redraw = true;
            }
        }
    }
    
    var _bgamma;
    property bgamma {
        getter() {
            if (env.colorall) {
				return env.stage.bgamma;
            } else {
                return _bgamma;
            }
        }
        setter(v) {
            _bgamma = v;
            if (!env.colorall) {
                redraw = true;
            }
        }
    }

	// 色状態の初期化
    function resetColor(param, elm) {
        _grayscale = void;
        _rgamma = void;
        _ggamma = void;
        _bgamma = void;
        if (!env.colorall) {
            redraw = true;
        }
    }
    
    /**
     * コンストラクタ
     * @param env 環境
     */
	function EnvImage(env, name) {
		super.EnvBase(env, name);
		cprops = %[];
		props = %[];
		actionList = [];
        _disp = CLEAR;
    }

	/**
	 * 画像を初期化
	 */
	function initImage() {
		(Dictionary.clear incontextof cprops)();
		setReset();
		disp = CLEAR;
	}

    function finalize() {
		invalidate actionList;
		invalidate props;
		super.finalize();
    }

	// -------------------------------------------------------
	// 初期化処理
	// -------------------------------------------------------

	function setReset(param, elm) {
		type    = void;
		setZoom(100);
		setRotate(0);
		setOpacity(255);
		_rgamma = void;
		_ggamma = void;
		_bgamma = void;
		_grayscale = void;
		redraw = true;
		updateFlag = true;
	}

	// -------------------------------------------------------

	/*
	 * 分割パラメータの前側を取得
	 * @param value パラメータ
	 */
	function getTo(value) {
		if (typeof value == "String") {
			var p;
			if ((p = value.indexOf(":")) > 0) {
				return value.substring(0, p);
			} else  if (p == 0) {
				return void;
			} else  {
				return value;
			}
		} else {
			return value === void ? value : +value;
		}
	}
	
	/*
	 * 分割パラメータの後側を取得
	 * @param value パラメータ
	 */
	function getFrom(value) {
		if (typeof value == "String") {
			var p;
			if ((p = value.indexOf(":")) >= 0) {
				return value.substring(p+1);
			} else {
				return void;
			}
		}
		return void;
	}

	function setPropFromTo(name, from, to, elm) {
		if (to !== void) {
			if (elm !== void && elm.time > 0) {
				//dm("値指定:" + name + ":" + from + ":" + to + ":" + elm.time);
				addAction(%[name =>	%[handler:"MoveAction",
								  start:from,
								  value:to,
								  time:elm !== void ? +elm.time:0,
								  accel:elm !== void ? +elm.accel:0]]);
			} else {
				//dm("値指定:" + name + ":" + to);
				addProp(name, to);
			}
		}
	}

	function setProp(name, param, elm) {
		if (param !== void) {
			var from = getFrom(param);
			if (from !== void) { from = +from; }
			var to = getTo(param);
			if (to !== void) { to = +to; }
			//dm("プロパティ設定:" + name + ":"  + from + ">" + to);
			setPropFromTo(name, from, to, elm);
		}
	}

	function setAfx(param, elm) {
		addProp("afx", param);
	} 

	function setAfy(param, elm) {
		addProp("afy", param);
	} 
	
	function setLeft(param, elm) {
		setProp("left", param, elm);
	} 

	function setTop(param, elm) {
		setProp("top", param, elm);
    }

	function setOpacity(param, elm) {
		setProp("opacity", param, elm);
	}

	function setRotate(param, elm) {
		setProp("rotate", param, elm);
	}

	function setZoom(param, elm) {
		setProp("zoomx", param, elm);
		setProp("zoomy", param, elm);
	}

	function setZoomx(param, elm) {
		setProp("zoomx", param, elm);
	}

	function setZoomy(param, elm) {
		setProp("zoomy", param, elm);
	}
	
	/**
	 * 相対値計算 Action.tjs からのコピー
	 * @param value 値指定
	 * @param orig オリジナルの値
	 */
	function getRelative(value, orig) {
		if (typeof value == "String" && (value.indexOf("@") >= 0)) {
			return Scripts.eval(value.replace(/@/, (string)orig));
		} else {
			return +value;
		}
	}

	/**
	 * プロパティ変更の反映
	 * @param props プロパティセット
	 * @param target 処理対象
	 */
	function applyProps(props, target) {
		var names = [];
		names.assign(props);
		for (var i=0; i<names.count; i+= 2) {
			var name  = names[i];
			var value = names[i+1];
			if (target[name] !== value) {
				target[name] = value;
			}
		}
	}
	
    /**
	 * アクションの適用
	 * @param action アクション情報
	 * @param target 処理対象
	 */
	function _applyMoveAction(action, target) {
		var names = [];
		names.assign(action);
		for (var i=0; i<names.count; i+= 2) {
			var name  = names[i];
			var info  = names[i+1];
			if (typeof info == "Object" && info !== null && info.handler == "MoveAction" && info.value !== void) {
				//dm("アクション適用 " + name + ":" + info.value);
				var value = getRelative(info.value, cprops[name]);
				if (target[names] != value) {
					target[name] = value;
				}
			}
		}
	}

    /**
	 * アクションの適用
	 */
	function applyMoveAction(action, target) {
		if (action instanceof "Dictionary") {
			_applyMoveAction(action, target);
		} else if (action instanceof "Array" && action.count > 0) {
			for (var j=0;j<action.count;j++) {
				_applyMoveAction(action[j], target);
			}
		}
	}

	/**
	 * プロパティ変更情報の追加
	 */
	function addProp(name, value) {
		props[name] = value;
		updateFlag = true;
	}
	
    /**
	 * アクション情報の追加
	 * @param action アクション情報
     */
	function addAction(action) {
		actionList.add(action);
		updateFlag = true;
	}

    /**
     * アクションを設定
     * @param name アクション名
     * @param elm パラメータ
     */
	function setAction(name, elm) {
		if (env.actions !== void) {
			var info;
			if ((info = env.actions[name]) !== void) {
				if (info instanceof "Dictionary") {
					var action = player.copyActionInfo(info, info.time, elm);
					addAction(action);
					return true;
				} else if (info instanceof "Array") {
					//dm("配列アクション:" + name);
					var arrayAction = [];
					for (var i=0;i<info.count;i++) {
						var i = info[i];
						if (typeof i == "String") {
							// 文字列の場合再帰的に参照
							i = env.actions[i];
						}
						if (i !== void && i instanceof "Dictionary") {
							var action = player.copyActionInfo(i, i.time, elm);
							arrayAction.add(action);
						}
					}
					addAction(arrayAction);
					return true;
				}
				return false;
			}
			// 個別記述
            if (elm !== void && name.substring(0,5) == "Layer") {
				var module = Scripts.eval(name);
				if (module !== void) {
					// アクションモジュール名の場合
					var action = %[];
					foreach(elm, function(name, value, elm, action) {
						if (actionParam[name] !== void) {
							action[name] = value;
						}
					}, action);
					action.time   = +elm.time   if elm.time !== void;
					action.delay  = +elm.delay  if elm.time !== void;
					action = module(action);
					action.nowait = +elm.nowait if elm.nowait !== void;
					addAction(action);
					return true;
				}
            }
        }
        return false;
    }

    /**
	 * 全アクションを解除
     */
	function stopAction() {
		doStopAction = true;
		updateFlag = true;
    }

	// --------------------------------------------------------------

	var dispMode;
	var syncMode;
	var movieSyncMode;
	var prevShow;

	/**
	 * 状態更新処理
     */
	function updateLayer(layer) {
		if (doShow) {
			//dm("表示変更!");
			layer.visible = isShowBU();
		}
		// レイヤパラメータ反映
		if (type !== void && layer.type != type) { layer.type = type; }
		if (width !== void && width != layer.width || height !== void && height != layer.height) {
			layer.setSize(width, height);
		}

		// プロパティ処理
		applyProps(props, layer);
		// アクション処理
		if (doStopAction) {
			layer.stopAction();
			doStopAction = false;
		}
		for (var i=0;i<actionList.count;i++) {
			layer.beginAction(actionList[i]);
		}

		// アクション終了まち
		ret = player.waitAction(layer, syncMode, movieSyncMode);
	}

	var imageCommands = %[
	type : function(param, elm) { type =  global[param]; } incontextof this,
	afx : this.setAfx incontextof this,
	afy : this.setAfy incontextof this,
	xpos : this.setLeft incontextof this,
	ypos : this.setTop incontextof this,
	left : this.setLeft incontextof this,
	top : this.setTop incontextof this,
	opacity : this.setOpacity incontextof this,
	rotate : this.setRotate incontextof this,
	zoom : this.setZoom incontextof this,
	zoomx : this.setZoomx incontextof this,
	zoomy : this.setZoomy incontextof this,
	reset : this.setReset incontextof this,
    grayscale : function(param, elm) { grayscale = param;  } incontextof this,
    rgamma : function(param, elm) { rgamma = param; } incontextof this,
    ggamma : function(param, elm) { ggamma = param; } incontextof this,
    bgamma : function(param, elm) { bgamma = param; } incontextof this,
    resetcolor : this.resetColor incontextof this,
    action : setAction incontextof this,
    stopaction : stopAction incontextof this,
	sync : function(param) { if (param) { syncMode = true; } } incontextof this,
	waitmovie : function(param) { if (param) { movieSyncMode = true; } } incontextof this,
	show : function(param) { disp = SHOW; },
	hide : function(param) { disp = CLEAR; },
	accel : null, // 無視
	fade : null, // 無視
	nosync : null, // 無視
	nowait : null, // 無視
        ];

    /**
     * コマンドの実行
	 * @param cmd コマンド
	 * @param param パラメータ
     * @param elm 他のコマンドも含む全パラメータ
     * @return 実行が行われた場合 true
     */
    function doCommand(cmd, param, elm) {

		// 共通コマンド
		if (super.doCommand(cmd, param, elm)) {
			return true;
        }
		
		// Image系共通コマンド
		var func;
		if ((func = imageCommands[cmd]) !== void) {
			if (func != null) {
				func(param, elm);
            }
			return true;
		}

		// アクション
		if (setAction(cmd, elm)) {
			return true;
		}

		// アクションパラメータの排除
		if (actionParam[cmd] !== void) {
			return true;
		}

		return false;
	}
	
    // このメソッドを実装する
    // function getLayer(isfore);
	// function drawLayer(layer)

	/**
	 * 新レイヤ生成
	 */
	function createLayer(isfore) {
		return new EnvGraphicLayer(this, isfore);
	}

	// -------------------------------------------------------------------------------

	/**
	 * 単純更新
	 */
	function update(isfore) {
		//dm("更新処理:" + name + ":" + layerOn + ":" + updateFlag + ":" + redraw);
		if (layerOn && (updateFlag || redraw)) {
			var layer = getLayer(isfore);
			if (redraw) {
				//dm("再描画:" + name);
				//layer.reset();
				layer.type = type if type !== void;
				drawLayer(layer);
				if (grayscale) {
					layer.doGrayScale();
				}
				if (rgamma != void || ggamma != void || bgamma != void) {
					layer.adjustGamma(rgamma == void ? 1.0 : rgamma, 0, 255,
									  ggamma == void ? 1.0 : ggamma, 0, 255,
									  bgamma == void ? 1.0 : bgamma, 0, 255);
				}
				// プロパティの再反映
				applyProps(cprops, layer);
				layer.recalcPosition();
				redraw = false;
			}
			updateLayer(layer);
			updateFlag = false;
			return layer;
		}
		updateFlag = false;
	}

	/**
	 * 表示更新前のフラグ初期化
	 */
	function tagcommand(elm) {
		syncMode = void;
		movieSyncMode = void;
		layerOn = prevShow = isShowBU();
		dispMode = 0;
		actionList.clear();
		(Dictionary.clear incontextof props)();
		super.tagcommand(elm);
	}

	function tagdone(elm) {
		super.tagdone(elm);
		// アクション情報反映
		for (var i=0;i<actionList.count;i++) {
			applyMoveAction(actionList[i], props);
		}
		// プロパティ情報反映
		applyProps(props, cprops);
	}

	// -----------------------------------------------
	
	/**
	 * 表示処理用の自動トランジションの指定
	 */
	function setDispAutoTrans() {
	}
	
	function command(elm) {
		super.command(elm);
		// 0:非表示 1:表示 2:消去 3:更新
		dispMode = (prevShow ? 2 : 0) + (isShowBU() ? 1 : 0);
		// 表示・消去指定に対応
		if (dispMode == 1 || dispMode == 2) {
			setDispAutoTrans();
		}
	}
	
	/**
	 * 表示更新処理特殊化
	 */
	function doUpdate(elm) {
		//dm("doUpdate:" + name + ":" + dispMode);
		if (dispMode == 1 && trans.showaction !== void) {
			//dm("画像表示");
			doShow = false;
			var layer = update(true);
			if (layer !== void) {
				player.beginTransAction(trans, layer, false, elm !== void && elm.nosync);
			}
		} else if (dispMode == 2 && trans.hideaction !== void) {
			//dm("画像消去");
			doShow = false;
			var layer = update(true);
			if (layer !== void) {
				player.beginTransAction(trans, layer, true, elm !== void && elm.nosync);
			}
		} else {
			//dm("画像更新:" + trans.method + ":" + trans.showaction + ":" + trans.hideaction);
			if (trans.showaction !== void && trans.hideaction !== void) {
				//dm("表示消去アクションを実行:name");
				// 現在のレイヤを消去アクション
				// 新レイヤを表示アクション
				var oldLayer = targetLayer != null ? player.getNewLayer(this, true, targetLayer, false) : null;
				doShow = false;
				var layer = update(true);
				if (oldLayer !== void) {
					//dm("旧レイヤを消去:" + name);
					if (layer !== void) {
						oldLayer.absolute = layer.absolute - 1;
					}
					var time = trans.hidetime !== void ? trans.hidetime : trans.time;
					var delay = trans.hidedelay;
					var hideaction = player.copyActionInfo(trans.hideaction, time, %[delay:delay]);
					hideaction["visvalue"] = %[ handler:MoveAction, value:0, time:time, delay:delay ];
					player.addTag("action", %[target:oldLayer, action:hideaction]);
					player.trashLayer(oldLayer);
				}
				if (layer !== void) {
					//dm("新レイヤを表示:" + name);
					layer.visvalue = 0;
					var time  = trans.showtime !== void ? trans.showtime : trans.time;
					var delay = trans.showdelay;
					var showaction = player.copyActionInfo(trans.showaction, time, %[delay:delay]);
					showaction["visvalue"] = %[ handler:MoveAction, value:100, time:time, delay:delay];
					player.addTag("action", %[target:layer, action:showaction]);
				}
				player.addTag("wact");
			} else {
				player.backup();
				var layer = update(false);
				player.beginTransition(trans);
			}
		}
	}
}

EnvImage.BOTH      = 1;
EnvImage.BU        = 2;
EnvImage.FACE      = 3;
EnvImage.SHOW      = 4;
EnvImage.CLEAR     = 5;
EnvImage.INVISIBLE = 6;
