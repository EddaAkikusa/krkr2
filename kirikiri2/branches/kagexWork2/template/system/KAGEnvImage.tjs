/**
 * 環境用レイヤ
 * ・座標配置調整機能を持つ
 */
class EnvGraphicLayer extends GraphicLayerBase {

	var owner;

	/**
	 * コンストラクタ
	 * @param owner オブジェクト情報をもってる親
	 * @param isfore 表画面か裏画面か
	 */
	function EnvGraphicLayer(owner, isfore) {
		this.owner = owner;
		super.GraphicLayerBase(isfore);
	}

	var _left;
	property left {
		getter() {
			return _left;
		}
		setter(v) {
			_left = v;
			recalcPosition();
		}
	}
	var _top;
	property top {
		getter() {
			return _top;
		}
		setter(v) {
			_top = v;
			recalcPosition();
		}
	}

	function setPos(left, top, width, height) {
		//dm("座標設定:" + left + "," + top);
		this.width = width if width !== void; 
		this.height = height if height !== void;
		_left = left;
		_top  = top;
		recalcPosition();
	}
	
	/**
	 * 配置位置調整
	 */
	function recalcPosition() {
		setRealPosition(left, top);
	}

	function setRealPosition(left, top) {
		super.left = left;
		super.top  = top;
	}
	
};

/**
 * 環境画像の基底クラス
 */
class KAGEnvImage extends KAGEnvBase {

	// デフォルト情報
	var init;

	var layerOn; //< レイヤが有効になっている
	var doShow;  //< 表示処理実行
	
	/// 表示状態変更
    // BOTH      バストアップ＋フェイス (標準）
    // BU        バストアップ
    // FACE      フェイス
	// SHOW      表示状態（自動選択）
	// CLEAR     消去状態 (標準)
    // INVISIBLE 非表示
	var _disp;
	property disp {
		getter() {
			return _disp;
		}
		setter(v) {
			if (v !== _disp) {
				if (v == SHOW) {
					if (isClear()) {
						if (init !== void && init.noPose !== void) {
							_disp = init.noPose ? FACE : BOTH;
						} else {
							_disp = BOTH;
						}
					}
				} else {
					_disp = v;
				}
				doShow = true;
				if (isShowBU()) {
					layerOn = true;
					redraw = true;
				}
				updateFlag = true;
			}
		}
	}

	// バストアップ表示中
	function isShowBU() {
		return _disp <= BU;
    }

	// フェイス表示中
    function isShowFace() {
        return (_disp == BOTH && env.bothFace)|| _disp == FACE;
    }

	// 表示されているか
	function isShow() {
        return _disp <= FACE;
	}

	// 消去状態か
	function isClear() {
		return _disp == CLEAR;
	}

	// 更新フラグ
	var updateFlag;
    // 再描画指示フラグ
    var redraw;

    /**
     * 時間用最初期化処理
     */
    function setRedraw() {
		if (isShowBU()) {
			redraw = true;
		}
    }
	
	// -----------------------------------------------------------------------
	// レイヤ制御
	// -----------------------------------------------------------------------

    // 種別
	var _type;
	property type {
		getter() {
			return _type;
		}
        setter(v) {
			_type = v;
			updateFlag = true;
        }
    }

	// サイズ指定
	var _width;
	property width {
		getter() {
			return _width;
		}
		setter(v) {
			_width = v;
			updateFlag = true;
		}
	}
	
	var _height;
	property height {
		getter() {
			return _height;
		}
		setter(v) {
			_height = v;
			updateFlag = true;
		}
	}
	
	var props = %[];
	
    // アクション処理
	var doStopAction;
	var actionList;

    // 画像補整指定
    var _grayscale;
    property grayscale {
        getter() {
            if (env.colorall) {
                return env.stage.grayscale;
            } else {
                return _grayscale;
            }
        }
        setter(v) {
            _grayscale = v;
            if (!env.colorall) {
                redraw = true;
            }
        }
    }

    var _rgamma;
    property rgamma {
        getter() {
            if (env.colorall) {
				return env.stage.rgamma;
            } else {
                return _rgamma;
            }
        }
        setter(v) {
            _rgamma = v;
            if (!env.colorall) {
                redraw = true;
            }
        }
    }

    var _ggamma;
    property ggamma {
        getter() {
			if (env.colorall) {
				return env.stage.ggamma;
            } else {
                return _ggamma;
            }
        }
        setter(v) {
            _ggamma = v;
            if (!env.colorall) {
                redraw = true;
            }
        }
    }
    
    var _bgamma;
    property bgamma {
        getter() {
            if (env.colorall) {
				return env.stage.bgamma;
            } else {
                return _bgamma;
            }
        }
        setter(v) {
            _bgamma = v;
            if (!env.colorall) {
                redraw = true;
            }
        }
    }

	// 色状態の初期化
    function resetColor(param, elm) {
        _grayscale = void;
        _rgamma = void;
        _ggamma = void;
        _bgamma = void;
        if (!env.colorall) {
            redraw = true;
        }
    }
    
    /**
     * コンストラクタ
     * @param env 環境
     */
	function KAGEnvImage(env, name) {
		super.KAGEnvBase(env, name);
		actionList = [];
        _disp = CLEAR;
    }

	function initImage() {
		type = void;
		props = %[];
		rgamma = void;
		ggamma = void;
		bgamma = void;
		grayscale = void;
		disp = CLEAR;
		actionList.clear();
	}

    function finalize() {
		invalidate actionList;
		super.finalize();
    }

	// -------------------------------------------------------
	// 初期化処理
	// -------------------------------------------------------

	var doReset;

	function setReset(param, elm) {
		type    = void;
		props   = %[];
		_rgamma = void;
		_ggamma = void;
		_bgamma = void;
		_grayscale = void;
		doReset = true;
		updateFlag = true;
	}

	// -------------------------------------------------------

	/*
	 * 分割パラメータの前側を取得
	 * @param value パラメータ
	 */
	function getTo(value) {
		if (typeof value == "String") {
			var p;
			if ((p = value.indexOf(":")) > 0) {
				return value.substring(0, p);
			} else  if (p == 0) {
				return void;
			} else  {
				return value;
			}
		} else {
			return value === void ? value : +value;
		}
	}
	
	/*
	 * 分割パラメータの後側を取得
	 * @param value パラメータ
	 */
	function getFrom(value) {
		if (typeof value == "String") {
			var p;
			if ((p = value.indexOf(":")) >= 0) {
				return value.substring(p+1);
			} else {
				return void;
			}
		}
		return void;
	}

	/**
	 * 場所指定 相対位置指定の判定。
	 * 指定値が "%" で終わっていたら最大値への相対での指定とみなす
	 * 指定値が "@" ではじまっていたら現在値への相対の指定とみなす
	 * @param base  現在値
	 * @param value 指定値
	 * @param valueBase 指定の最大値
	 */
	function calcRelative(base, value, valueBase) {
		if (value === void) {
			return value;
		} else {
			if (typeof value == "String") {
				// 相対指定の場合
				if (value.charAt(0) == '@') {
					value = value.substring(1);
					// %指定の場合
					if (valueBase !== void && value.charAt(-1) == '%') {
						value = valueBase * (int)value.substring(0,value.length - 1) / 100;
					}
					return (int)base + (int)value;
				} else {
					// %指定の場合
					if (valueBase !== void && value.charAt(-1) == '%') {
						value = valueBase * (int)value.substring(0,value.length - 1) / 100;
					}
				}
			}
			return (int)value;
		}
	}
	
	function setPropFromTo(name, max, from, to, elm) {
		if (to !== void) {
			// 初期値不定の場合は同じ値のまま処理
			if (props[name] === void && from === void) {
				from = to;
			}
			addAction(%[name =>	%[handler:"MoveAction",
							  start:calcRelative(props[name], from, max),
							  value:calcRelative(props[name], to, max),
							  time:elm !== void ? +elm.time:0,
							  accel:elm !== void ? +elm.accel:0]]);
		}
	}

	function setProp(name, max, param, elm) {
		setPropFromTo(name, max, getFrom(param), getTo(param), elm);
	}

	function setAfx(param, elm) {
		setProp("afx", width, param, elm);
	} 

	function setAfy(param, elm) {
		setProp("afy", height, param, elm);
	} 
	
	function setLeft(param, elm) {
		setProp("left", env.xmax, param, elm);
	} 

	function setTop(param, elm) {
		setProp("top", env.ymax, param, elm);
    }

	function setOpacity(param, elm) {
		setProp("opacity", 100, param, elm);
	}

	function setRotate(param, elm) {
		setProp("rotate", 360, param, elm);
	}

	function setZoom(param, elm) {
		setProp("zoom", 100, param, elm);
	}

	/**
	 * 相対値計算 Action.tjs からのコピー
	 * @param value 値指定
	 * @param orig オリジナルの値
	 */
	function getRelative(value, orig) {
		if (typeof value == "String" && (value.indexOf("@") >= 0)) {
			return Scripts.eval(value.replace(/@/, (string)orig));
		} else {
			return +value;
		}
	}

	/**
	 * アクションの適用
	 */
	function applyMoveAction(action) {
		var names = [];
		names.assign(action);
		for (var i=0; i<names.count; i+= 2) {
			var name  = names[i];
			var info  = names[i+1];
			if (typeof info == "Object" && info !== null && info.handler == "MoveAction" && info.value !== void) {
				//dm("アクション適用 " + name + ":" + info.value);
				props[name] = getRelative(info.value, props[name]);
			}
		}
	}

    /**
	 * アクション情報の追加
	 * @param action アクション情報
     */
	function addAction(action) {
		if (action instanceof "Dictionary") {
			actionList.add(action);
			applyMoveAction(action);
		} else if (action instanceof "Array" && action.count > 0) {
			actionList.add(action);
			for (var j=0;j<action.count;j++) {
				applyMoveAction(action[j]);
			}
		}
		updateFlag = true;
	}

    /**
     * アクションを設定
     * @param name アクション名
     * @param elm パラメータ
     */
	function setAction(name, elm) {
		if (env.actions !== void) {
			var info;
			if ((info = env.actions[name]) !== void) {
				if (info instanceof "Dictionary") {
					var action = player.copyActionInfo(info, info.time, elm);
					addAction(action);
					return true;
				} else if (info instanceof "Array") {
					//dm("配列アクション:" + name);
					var arrayAction = [];
					for (var i=0;i<info.count;i++) {
						var i = info[i];
						if (typeof i == "String") {
							// 文字列の場合再帰的に参照
							i = env.actions[i];
						}
						if (i !== void && i instanceof "Dictionary") {
							var action = player.copyActionInfo(i, i.time, elm);
							arrayAction.add(action);
						}
					}
					addAction(arrayAction);
					return true;
				}
				return false;
			}
			// 個別記述
            if (elm !== void && name.substring(0,5) == "Layer") {
				var module = Scripts.eval(name);
				if (module !== void) {
					// アクションモジュール名の場合
					var action = %[];
					foreach(elm, function(name, value, elm, action) {
						if (actionParam[name] !== void) {
							action[name] = value;
						}
					}, action);
					action.time   = +elm.time   if elm.time !== void;
					action.delay  = +elm.delay  if elm.time !== void;
					action = module(action);
					action.nowait = +elm.nowait if elm.nowait !== void;
					addAction(action);
					return true;
				}
            }
        }
        return false;
    }

    /**
	 * 全アクションを解除
     */
	function stopAction() {
		doStopAction = true;
		updateFlag = true;
    }

	// --------------------------------------------------------------

	var dispMode;
	var syncMode;
	var movieSyncMode;
	var prevShow;

	/**
	 * 状態更新処理
     */
	function updateLayer(layer) {

		//dm("updateLayer:" + name);
		if (doReset) {
			//dm("リセット処理");
			layer.reset();
		}
		if (doStopAction) {
			//dm("アクション停止");
			layer.stopAction();
		}
		if (doShow) {
			//dm("表示変更!");
			layer.visible = isShowBU();
		}
		// レイヤパラメータ反映
		if (type !== void && layer.type != type) { layer.type = type; }
		if (width !== void && width != layer.width || height !== void && height != layer.height) {
			layer.setSize(width, height);
		}
		// アクション処理
		for (var i=0;i<actionList.count;i++) {
			layer.beginAction(actionList[i]);
		}
		// アクション終了まち
		ret = player.waitAction(layer, syncMode, movieSyncMode);
	}

	var imageCommands = %[
	type : function(param, elm) { type =  global[param]; } incontextof this,
	afx : this.setAfx incontextof this,
	afy : this.setAfy incontextof this,
	xpos : this.setLeft incontextof this,
	ypos : this.setTop incontextof this,
	left : this.setLeft incontextof this,
	top : this.setTop incontextof this,
	opacity : this.setOpacity incontextof this,
	rotate : this.setRotate incontextof this,
	zoom : this.setZoom incontextof this,
	reset : this.setReset incontextof this,
    grayscale : function(param, elm) { grayscale = param;  } incontextof this,
    rgamma : function(param, elm) { rgamma = param; } incontextof this,
    ggamma : function(param, elm) { ggamma = param; } incontextof this,
    bgamma : function(param, elm) { bgamma = param; } incontextof this,
    resetcolor : this.resetColor incontextof this,
    action : setAction incontextof this,
    stopaction : stopAction incontextof this,
	sync : function(param) { if (param) { syncMode = true; } } incontextof this,
	waitmovie : function(param) { if (param) { movieSyncMode = true; } } incontextof this,
	show : function(param) { disp = SHOW; },
	hide : function(param) { disp = CLEAR; },
	accel : null, // 無視
	fade : null, // 無視
	nosync : null, // 無視
	nowait : null, // 無視
        ];

    /**
     * コマンドの実行
	 * @param cmd コマンド
	 * @param param パラメータ
     * @param elm 他のコマンドも含む全パラメータ
     * @return 実行が行われた場合 true
     */
    function doCommand(cmd, param, elm) {

		// 共通コマンド
		if (super.doCommand(cmd, param, elm)) {
			return true;
        }
		
		// Image系共通コマンド
		var func;
		if ((func = imageCommands[cmd]) !== void) {
			if (func != null) {
				func(param, elm);
            }
			return true;
		}

		// アクション
		if (setAction(cmd, elm)) {
			return true;
		}

		// アクションパラメータの排除
		if (actionParam[cmd] !== void) {
			return true;
		}

		return false;
	}
	
    // このメソッドを実装する
    // function getLayer(isfore);
	// function drawLayer(layer)

	/**
	 * 新レイヤ生成
	 */
	function createLayer(isfore) {
		return new EnvGraphicLayer(this, isfore);
	}

	// -------------------------------------------------------------------------------

	function applyProps(layer) {
		var names = [];
		names.assign(props);
		for (var i=0; i<names.count; i+= 2) {
			var name  = names[i];
			var value = names[i+1];
			if (layer[name] !== void) {
				layer[name] = value;
			}
		}
	}
	
	/**
	 * 単純更新
	 */
	function update(isfore) {
		//dm("更新処理:" + name + ":" + layerOn + ":" + updateFlag + ":" + redraw);
		if (layerOn && (updateFlag || redraw)) {
			var layer = getLayer(isfore);
			if (redraw) {
				//dm("再描画:" + name);
				layer.reset();
				layer.type = type if type !== void;
				drawLayer(layer);
				applyProps(layer);
				layer.recalcPosition();
				if (grayscale) {
					layer.doGrayScale();
				}
				if (rgamma != void || ggamma != void || bgamma != void) {
					layer.adjustGamma(rgamma == void ? 1.0 : rgamma, 0, 255,
									  ggamma == void ? 1.0 : ggamma, 0, 255,
									  bgamma == void ? 1.0 : bgamma, 0, 255);
				}
				redraw = false;
			}
			updateLayer(layer);
			updateFlag = false;
			return layer;
		}
		updateFlag = false;
	}

	/**
	 * 表示更新前のフラグ初期化
	 */
	function tagcommand(elm) {
		syncMode = void;
		movieSyncMode = void;
		layerOn = prevShow = isShowBU();
		dispMode = 0;
		doReset      = false;
		doStopAction = false;
		actionList.clear();
		super.tagcommand(elm);
	}

	/**
	 * 表示処理用の自動トランジションの指定
	 */
	function setDispAutoTrans() {
	}
	
	function command(elm) {
		super.command(elm);
		// 0:非表示 1:表示 2:消去 3:更新
		dispMode = (prevShow ? 2 : 0) + (isShowBU() ? 1 : 0);
		// 表示・消去指定に対応
		if (dispMode == 1 || dispMode == 2) {
			setDispAutoTrans();
		}
	}
	
	/**
	 * 表示更新処理特殊化
	 */
	function doUpdate(elm) {
		if (trans.method !== void || dispMode == 3) {
			//dm("画像更新:" + trans.method + ":" + trans.showaction + ":" + trans.hideaction);
			player.backup();
			var layer = update(false);
			player.beginTransition(trans);
			if (layer !== void) {
				player.beginTransActionUpdate(trans, layer);
			}
		} else if (dispMode == 2) {
			//dm("画像消去");
			doShow = false;
			var layer = update(true);
			player.beginTransAction(trans, layer, true, elm.nosync);
		} else if (dispMode == 1) {
			//dm("画像表示");
			doShow = false;
			var layer = update(true);
			player.beginTransAction(trans, layer, false, elm.nosync);
		} else {
			update(true);
		}
	}
}

KAGEnvImage.BOTH      = 1;
KAGEnvImage.BU        = 2;
KAGEnvImage.FACE      = 3;
KAGEnvImage.SHOW      = 4;
KAGEnvImage.CLEAR     = 5;
KAGEnvImage.INVISIBLE = 6;
