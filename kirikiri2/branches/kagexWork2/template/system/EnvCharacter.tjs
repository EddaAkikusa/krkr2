/**
 * キャラクタ用レイヤ
 * LEVEL に応じた座標補正機能を持つ
 */
class CharacterGraphicLayer extends EnvGraphicLayer {

	var yoffset;
	
	/**
	 * コンストラクタ
	 * @param owner オブジェクト情報をもってる親
	 * @param isfore 表画面か裏画面か
	 */
	function CharacterGraphicLayer(owner,isfore) {
		yoffset = owner.yoffset;
		super.EnvGraphicLayer(...);
	}

	function assign(src) {
		//dm("アサイン処理:" + yoffset);
		super.assign(src);
		this.yoffset = src.yoffset;
	}

	var _level;
	property level {
		getter() {
			return _level;
		}
		setter(v) {
			_level = v;
			recalcPosition();
		}
	}
	
	function recalcPosition() {
		//dm("キャラ表示:" + name + ":" + yoffset + ":"  +level + ":" + left + ":" + top);
		// レベル別座標補正処理。とりあえず適当で画面中央に向かって縮小処理してある
		var zoom = 100;
		var levelYoffset = 0;
		var levelInfo = owner.env.levels[level];
		if (levelInfo !== void) {
			if (levelInfo.zoom !== void) {
				zoom = (int)levelInfo.zoom;
			}
			if (levelInfo.yoffset !== void) {
				levelYoffset = (int)levelInfo.yoffset;
			}
		}
		var x = owner.env.xmax + (+left * +zoom / 100) - width / 2;
		var y = owner.env.ymax + ((yoffset - +top) * zoom / 100) - height + levelYoffset;
		//dm("表示位置:" + x + "," + y + ":" + levelYoffset + ":" + zoom);
		setRealPosition(x, y);
	}
};

/**
 * キャラクタレイヤ
 * ポーズの指定他
 */
class EnvCharacter extends EnvLevelLayer, EnvImage {

	/// 初期化名
    var initName;

    /// 初期化情報
    var poses;

    // 画像ファイル直接指定
    var image;
    // 個別オフセット補正
	var _yoffset;
	property yoffset {
		getter() {
			return _yoffset !== void ? _yoffset  : init.yoffset !== void ? init.yoffset : env.yoffset;
		}
		setter(v) {
			_yoffset = v;
		}
	}
    
    /// ポーズ
    var _pose;
    property pose {
        getter() {
            if (_pose !== void) {
                return _pose;
            }
            if (init.defaultPose !== void) {
                return init.defaultPose;
            }
            return "通常";
        }
        setter(v) {
            _pose = v;
        }
    };

    /// 服装
    var dress;
    /// 表情
    var face;

	// 表情とポーズの対応表
    var facePoseMap;
    
    /**
     * コンストラクタ
     * @param env 環境オブジェクト
     * @param name キャラクタ名
     * @param init キャラクタ初期化データ
     */
    function EnvCharacter(env, name, initName, init) {

		global.EnvImage.EnvImage(env, name);
		global.EnvLevelLayer.EnvLevelLayer();
        
		//dm("キャラクタ登録:" + name); 

		this.initName = initName;
		this.init     = init;
		if (init) {
			poses = init.poses; //showKeys("poses", poses);
			
			// 表情ポーズ同期機能
            if (init.facePose) {
				// 表情からポーズに対するマップを作成する
                facePoseMap = %[];
                foreach(poses, function(name, value, dict, facePoseMap) {
                    var faces = [];
                    faces.assign(value.faces);
                    for (var i=0; i<faces.count; i+= 2) {
                        facePoseMap[faces[i]] = name;
                    }
                }, facePoseMap);
			}
		}

		// 未初期化時デフォルト
		setLeft(env.defaultXpos);
		setTop(env.defaultYpos);
    }
    
    function finalize() {
		// 順番変更不可注意
		global.EnvLevelLayer.finalize();
		global.EnvImage.finalize();
    }

    // 表情描画処理を行う
    var redrawFace;

    /**
     * 直接画像指定
     */
    function setImage(imageName, elm) {
		if (imageName != image || isClear()) {
			image   = imageName;
			yoffset = elm.yoffset;
			if (elm.hide === void) {
				disp = SHOW;
				redraw  = true;
				setAutoTrans([init.poseTrans, init.charTrans, env.envinfo.poseTrans, env.envinfo.charTrans]);
			}
		}
    }
    
    /**
     * ポーズの設定
     */
    function setPose(poseName, elm) {
        var info = poses[poseName];
        if (info !== void) {
			if (poseName != pose || isClear()) {
				pose = poseName;
				yoffset = info.yoffset;
				if (elm.hide === void) {
					disp = SHOW;
					redraw = true;
					setAutoTrans([info.trans, init.poseTrans, init.charTrans, env.envinfo.poseTrans, env.envinfo.charTrans]);

					// 表情表示取得
					if (isShowFace() && (elm.faceon || env.showFaceMode) && !elm.faceoff) {
						redrawFace = true;
					}
				}
            }
			// 服装初期化処理
			if (dress !== void && (info.dresses == void || info.dresses[dress] == void)) {
				dress = void;
			}
			// 表情初期化処理
			if (face !== void && (info.faces == void || info.faces[face] == void)) {
				face = void;
			}
        }

        // イメージを破棄
		image = void;
		// Y座標はポーズ設定したときに初期値に戻す
		setTop(env.defaultYpos);
    }

    /**
     * 服装の設定
     */
    function setDress(dressName, elm) {
		if (dressName != dress || isClear()) {
			dress = dressName;
			if (elm.hide === void) {
				disp = SHOW;
				redraw = true;
				setAutoTrans([init.dressTrans, init.charTrans, env.envinfo.dressTrans, env.envinfo.charTrans]);
				// 表情表示取得
				if (isShowFace() && (elm.faceon || env.showFaceMode) && !elm.faceoff) {
					redrawFace = true;
				}
			}
		}
		image = void;
    }
    /**
     * 表情の設定
      */
    function setFace(faceName, elm) {
		if (faceName != face || isClear()) {
			face = faceName;
			if (elm.hide === void) {
				disp = SHOW;
				redraw = true;
				setAutoTrans([init.faceTrans, init.charTrans, env.envinfo.faceTrans, env.envinfo.charTrans]);
				// 表情表示取得
				if (isShowFace() && (elm.faceon || env.showFaceMode) && !elm.faceoff) {
					redrawFace = true;
				}
			}
		}
		image = void;
    }

	// 表示位置指定
	var posName;
	
    /**
     * 表示位置の設定
     */
    function setPosition(cmd, elm) {

		var istrans = false;
		
		posName = getTo(cmd);
		var info;
		if (env.positions === void || (info = env.positions[posName]) === void) {
			return;
        }
		var istrans = false;
		
		if (info.xpos !== void || info.ypos !== void) {
			if (elm.hide === void && disp == CLEAR) {
				disp = SHOW;
				istrans = true;
			}
			var posFrom = getFrom(cmd);
			var fromInfo;
			if (posFrom !== void && (fromInfo = env.positions[posFrom]) !== void) {
				if (info.xpos !== void) {
					setPropFromTo("left", fromInfo.xpos, info.xpos, elm);
				}
				if (info.ypos !== void) {
					setPropFromTo("top", fromInfo.ypos, info.ypos, elm);
				}
			} else {
				if (info.xpos !== void) {
					setPropFromTo("left", void, info.xpos, elm);
				}
				if (info.ypos !== void) {
					setPropFromTo("top", void, info.ypos, elm);
				}
			}
		}

		if (info.level !== void) {
			level = info.level;
			redraw = true;
			if (elm.hide === void && disp == CLEAR) {
				disp = SHOW;
				istrans = true;
			}
		}

		if (info.disp !== void) {
			disp = info.disp;
			istrans = true;
		}
		
		if (info.trans !== void) {
			setDispTrans([info.trans]);
		} else {
			if (istrans) {
				setDispTrans([env.envinfo.positionTrans]);
			}
		}

		// 未初期化時デフォルト
		if (cprops.left === void) {
			cprops.left = env.defaultXpos;
		}
		if (cprops.top === void) {
			cprops.top = env.defaultYpos;
		}
	}

    var charCommands = %[
    image   : this.setImage incontextof this,
    dress   : this.setDress incontextof this,
    face    : function(cmd,elm) {
        if (facePoseMap !== void) {
            var p;
            if ((p = facePoseMap[cmd]) !== void) {
                setPose(p,elm);
                setFace(cmd,elm);
            }
        } else {
            setFace(cmd,elm);
        }
    }incontextof this,
    front   : this.setFront incontextof this,
    back    : this.setBack incontextof this,
	level   : this.setLevel incontextof this,
    pos     : this.setPosition incontextof this,
	facewin : function(param, elm) { disp = FACE; redraw = true; } incontextof this,
	faceon : null,
	faceoff : null,
        ];

    /**
     * ポーズ指定を優先処理する
     */
    function doPoseCommand(cmd, param, elm) {

        // ポーズコマンド
        if (cmd == "pose") {
            setPose(param, elm);
            return true;
        }

        // 顔ポーズマップが存在する場合
        if (facePoseMap !== void) {
            var p;
            if ((p = facePoseMap[cmd]) !== void) {
                setPose(p,elm);
                setFace(cmd,elm);
                return true;
            }
        }
        
        // ポーズ指定
        if (poses !== void) {
            if (poses[cmd] !== void) {
                setPose(cmd,elm);
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * コマンドの実行
     * @param cmd コマンド
     * @param param パラメータ
     * @param elm 他のコマンドも含む全パラメータ
     * @return 実行が行われた場合 true
     */
    function doCommand(cmd, param, elm) {

        if (global.EnvImage.doCommand(cmd, param, elm)) {
            return true;
        }

        var func;
        if ((func = charCommands[cmd]) !== void) {
            if (func != null) {
                func(param, elm);
            }
            return true;
        }
        
        var info;
        var find = false;

        if (!find && poses !== void && pose !== void && image === void) {
            var poseInfo;
            if ((poseInfo = poses[pose]) !== void) {
                var dresses       = poseInfo.dresses;
                var faces         = poseInfo.faces;
                if (dresses !== void && dresses[cmd] !== void) {
                    //dm("服装を設定");
                    find = true;
                    setDress(cmd,elm);
                } else if (faces !== void && faces[cmd] !== void) {
                    //dm("表情を設定");
                    find = true;
                    setFace(cmd,elm);
                }
            } else {
                dm("ポーズ情報がありません:" + pose + ":" + cmd);
            }
        }

		var posName = getTo(cmd);
        if (!find && env.positions !== void && env.positions[posName] !== void) {
            setPosition(cmd, elm);
            find = true;
        }            

        return find;
    };

	/**
	 * 立ち絵画像の取得
	 * @param levelName 現在の表示レベル
	 * @param pose      ポーズ指定
	 */
	function _getPoseImage(levelName, pose) {
		var poseInfo;
		if (poses !== void && (poseInfo = poses[pose]) !== void) {

			var imageFile;
			
			// 顔描画の場合は msgImage / msgFaceImage を優先
			var imageName     = (levelName == env.faceLevelName && poseInfo.msgImage !== void) ? poseInfo.msgImage : poseInfo.image;
			var dresses       = poseInfo.dresses;
			var faces         = poseInfo.faces;

			imageName = imageName.replace(/LEVEL/, levelName);
			
			// 服装指定が無い場合はデフォルトを参照
			var dressName;
			if (dress !== void) {
				dressName = dresses[dress];
            } 
			dressName = poseInfo.defaultDress if dressName === void;

            // 表情指定が無い場合はデフォルトを参照
            var faceName;
            if (face !== void) {
                faceName = faces[face];
            }
            faceName = poseInfo.defaultFace if faceName === void;

            //dm("dress:", dressName, "face:", faceName);
            
			// 顔合成型立ち絵
			// 服装情報で上書き
			if (dressName !== void) {
				imageFile = imageName.replace(/DRESS/, dressName);
			} else {
				imageFile = imageName;
			}
			// 表情で上書き
			if (faceName !== void) {
				imageFile = imageFile.replace(/FACE/, faceName);
			}
			return imageFile;
		}
	}
	
	/**
	 * 立ち絵画像の取得
	 * @param levelName 現在の表示レベル
	 */
	function getPoseImage(levelName) {
		var imageName = _getPoseImage(levelName, pose);
		if (imageName == void || !isExistImageName(imageName) && pose != init.defaultPose) {
			imageName = _getPoseImage(levelName, init.defaultPose);
		}
		return imageName;
	}

    /**
     * 現在の立ち絵の描画
     * @param layer 描画対象レイヤ
     */
	function drawLayer(layer) {
		if (isShowBU()) {

			// レベルで補正
			var levelName;
			var levelInfo = env.levels[level];
			if (levelInfo !== void) {
				levelName = levelInfo.name;
			}
			if (levelName === void) {
				levelName = level;
			}

			// 画像を決定
			var imageName;
			if (image !== void) {
				imageName = image.replace(/LEVEL/, levelName);
			} else {
				imageName = getPoseImage(levelName);
			}

			// 画像のロード
			try {
				var elm = %[ storage:imageName ];
				// 色補正
				var timeInfo;
				if ((timeInfo = env.currentTime) !== void) {
					elm.lightcolor = timeInfo.charLightColor;
					elm.lighttype  = timeInfo.charLightType;
					elm.brightness = timeInfo.charBrightness;
					elm.contrast   = timeInfo.charContrast;
				}
				layer.loadImages(elm);
			} catch (e) {
				player.errorImage(imageName + ":立ち絵画像がロードできません");
				return;
			}
			// サイズ補正
			layer.setSizeToImageSize();
			_width  = layer.width;
			_height = layer.height;
		}
	}

	/**
	 * 新レイヤ生成
	 */
	function createLayer(isfore) {
		return new CharacterGraphicLayer(this, isfore);
	}
	
    /**
     * レイヤ状態更新処理
     * エモーション処理を追加
     */
	function updateLayer(layer) {
		global.EnvImage.updateLayer(...);
		
		// 表情描画
		if (redrawFace) {
			// 表情と名前の再描画指定 XXXXX
			redrawFace = false;
        }
    }

	// ------------------------------------------------------
	
	/**
	 * タグ処理
	 * @param elm コマンドパラメータ
	 */
	function command(elm) {
		var e = %[];
		(Dictionary.assign incontextof e)(elm); 
		var names = [];
		names.assign(e);
		// ポーズ指定コマンドを優先処理する
		for (var i=0; i<names.count; i+= 2) {
			if (doPoseCommand(names[i], names[i+1], e)) {
				delete e[names[i]];
			}
		}
		global.EnvImage.command(e);
	}

	/**
	 * 表示処理用の自動トランジションの指定
	 */
	function setDispAutoTrans() {
		setDispTrans([init.dispTrans, env.envinfo.charDispTrans]);
	}

	// フェード指定のデフォルト値
	property fadeValue {
		getter() {
			if (init !== void && init.fadeValue !== void) {
				return init.fadeValue;
			} else {
                if (env.envinfo !== void && env.envinfo.charFadeValue !== void) {
					return env.envinfo.charFadeValue;
				} else {
					return env.fadeValue;
				}
			}
        }
    }
};
