<?xml version="1.0" encoding="Shift_JIS" ?>
<doc>
<title>プロパティ</title>

<para>
<ptitle>プロパティ</ptitle>
　プロパティとは、変数と同じように扱うことができるが、実際はメソッド呼び出しと同様に、<kw>セッター</kw> ( <kw>setter</kw> ) と<kw>ゲッター</kw> ( <kw>getter</kw> ) の呼び出しを伴うものです。<r/>
<r/>
　構文は以下の通りです。<r/>
<bq>
<kw>property</kw> 識別子<r/>
{<r/>
	setter(引数)<r/>
	{<r/>
		// ここにセッターの内容<r/>
	}<r/>
<r/>
	getter()<r/>
	{<r/>
		// ここにゲッターの内容<r/>
		return 式; // ゲッターとして返す値<r/>
	}<r/>
}<r/>
</bq>
　setter と getter は、逆の順番で書かれていてもかまいません。 <r/>
　この property を記述したクラスや、グローバルのメンバとしてこのプロパティは登録されますが、この識別子からの値の取得はゲッター、値の設定はセッターを通して行われます。これらのセッターとゲッターは、メソッド同様に様々な内容を書くことができます。セッターは setter に続く ( ) 内に、値を受け取る変数を引数として書きます。ゲッターは <kw>return</kw> ステートメントにて値を返します。<r/>
<r/>
　getterのあとの () は省略できます。 <r/>
<r/>
　一つの識別子に対し、セッターとゲッターの両方を書けば、読み書きの両方が可能なプロパティになります。一方しか書かない場合、たとえばゲッターしか書かない場合は、読み出し専用のプロパティとなり、書き込みはエラーになります。<r/>
<example>
	var value;<r/>
<r/>
	property property1 // プロパティ 'property1' を宣言<r/>
	{<r/>
		setter(v)<r/>
		{<r/>
			// セッターはただ一つだけの引数をとる<r/>
			value=v; // 引数 v を処理する<r/>
<r/>
			inform("value set.");<r/>
		}<r/>
<r/>
		getter<r/>
		{<r/>
			// propset と同じ識別子 'property1' のゲッターを宣言<r/>
			// ゲッターに引数はない<r/>
			inform("value get.");<r/>
			return value; // 戻り値として返す<r/>
		}<r/>
	}<r/>
<r/>
	property1=5; // property1 への代入は、セッターが呼ばれる<r/>
	property1++; // このような式では、ゲッターが呼ばれ、<r/>
	             // 次にセッターが呼ばれて値が設定される<r/>
}<r/>
</example>
　プロパティも変数や関数やクラス同様、<kw>オーバーライド</kw>できます。<r/>
</para>

<para>
<ptitle>プロパティオブジェクト</ptitle>
　プロパティ自身も一つのオブジェクトですが、なんらかのオブジェクトのメンバとして登録されない限りプロパティとして動作できません。<r/>
　プロパティオブジェクトそのものを取り出すには <tt><kw>*</kw></tt> 演算子を使います。また、<tt>*</tt> 演算子を使ってプロパティオブジェクトを登録することもできます。<r/>
<example>
	property prop // プロパティ prop を宣言<r/>
	{<r/>
		(略)<r/>
	}<r/>
<r/>
	var p = *prop; // プロパティオブジェクトを得る<r/>
<r/>
	*object.property1 = p; // p を object の property1 として登録する<r/>
</example>
<r/>
　<tt>*</tt> 演算子を使うと、ゲッターやセッターは呼ばれずにプロパティオブジェクトそのものにアクセスする事ができます。<tt>*</tt> 演算子を使わなければ通常のプロパティへのアクセスとなります。<r/>
</para>
</doc>
