// KAGPAWidgitLayer.tjs - ボタンレイヤ
// Copyright (C)2006, SB@Nomadiclife  改変・配布は自由です


/*! 縦置きに対応したSliderLayer

	SliderLayer上位互換、verticalにtrueを設定しない時はSliderLayerそのものです。
	Slider_tabHeightはSlider_tabWidthをラップしているだけです。

	drawHighLightをfalseにすれば、フォーカスが渡った場合でもハイライト(枠)を描画しません。
	drawLineをfalseにすれば、中央部のラインを描画しません。
	これら２つのプロパティは、初期状態ではtrueとなっています。
	10/7追加
	タブの左右(上下)でセンターのラインの色を変えられるようにした

*/

 class exSliderLayer extends SliderLayer{
	
	var Slider_vertical;//縦向きか
	var Slider_drawHighLight;//ハイライトを描画するか
	var Slider_drawLine;//中央部のラインを描画するか

 function exSliderLayer(win,par){
	super.SliderLayer(...);
	Slider_drawHighLight = true;
	Slider_drawLine = true;
	update();
	}

 function finalize(){
	super.finalize(...);
	}

 function assign(src){
	vertical = src.Slider_vertical;
	super.assign(...);
	}

 function onPaint(){

	global.Layer.onPaint();

	if(Slider_vertical){//縦

		var imw = imageWidth, imh = imageHeight;
		var tabh = Slider_tabHeight;
		var htabh = tabh >> 1;

		// 下敷きを塗る
		fillRect(0, 0, imw, imh, 0);

		if(focused&&Slider_drawHighLight){
			// フォーカスがあるのでハイライトする
			colorRect(0, 0, width-1, 1, clHighlight, 128);
			colorRect(0, 1, 1, height-2, clHighlight, 128);
			colorRect(0, height-1, width, 1, clHighlight, 128);
			colorRect(width-1, 0, 1, height-1, clHighlight, 128);
			}

		//中央のライン
		if(Slider_drawLine){
			var himw = imw >> 1;
			var bottom = imh - tabh;
			//下
			fillRect(himw - 1,htabh,1,bottom,0x80000000);
			fillRect(himw,htabh,1,bottom,0x80FFFFFF);
			}

		//タブ
		var pos_y = int(
			(Slider_position-Slider_min) * (imh - tabh - 2)/(Slider_max - Slider_min))
			 + htabh + 1;
		var y_htabh = pos_y - htabh;
		//中央のラインその2
		if(Slider_drawLine){
			var himw = imw >> 1;
			fillRect(himw - 1,htabh,1,y_htabh,0x80000000);
			fillRect(himw,htabh,1,y_htabh,0x80FF0000);
			}
		fillRect(0,y_htabh,imw,tabh,0xFFFFFF + (nodeEnabled ? 0:0xc0000000));
		if(Slider_mouseOn){
			colorRect(0,y_htabh,imw,tabh,clHighlight,64);
			}
		colorRect(0,y_htabh + 1, 1, tabh-2, 0xffffff, 128);
		colorRect(imw-1,y_htabh + 1,1,tabh-2,0x000000,128);
		colorRect(0,y_htabh,width,1,0xFFFFFF,128);
		colorRect(0,pos_y + htabh - 1,1,width,1,0x000000,128);
	}else{

		// よく使う値をローカル変数に用意する
		var imw = imageWidth, imh = imageHeight;
		var tabw = Slider_tabWidth;
		var htabw = tabw >> 1;

		// 下敷きを塗る
		fillRect(0, 0, imw, imh, 0);

		if(focused&&Slider_drawHighLight)
		{
			// フォーカスがあるのでハイライトする
			colorRect(0, 0, width-1, 1, clHighlight, 128);
			colorRect(0, 1, 1, height-2, clHighlight, 128);
			colorRect(0, height-1, width, 1, clHighlight, 128);
			colorRect(width-1, 0, 1, height-1, clHighlight, 128);
		}

		// 中央のへこみ線
		if(Slider_drawLine){
			var himh = imh >> 1;
			var right = imw - tabw;
			fillRect(htabw, himh - 1, right, 1, 0x80000000);
			fillRect(htabw, himh, right, 1, 0x80ffffff);
		}

		// タブ
		var pos_x = int(
			(Slider_position-Slider_min) * (imw - tabw - 2)/(Slider_max - Slider_min)) +
			htabw + 1;
		var x_htabw = pos_x - htabw;
		dm("x_htabw:" +x_htabw);
		// 中央のへこみ線2
		if(Slider_drawLine){
			var himh = imh >> 1;
			fillRect(htabw, himh - 1, x_htabw, 1, 0x80000000);
			fillRect(htabw, himh, x_htabw, 1, 0x80ff0000);
		}
		fillRect(x_htabw, 0, tabw, imh, 0xffffff + (nodeEnabled ? 0 : 0xc0000000));
		if(Slider_mouseOn)
		{
			colorRect(x_htabw, 0, tabw, imh, clHighlight, 64);
		}
		colorRect(x_htabw + 1, 0, tabw-2, 1, 0xffffff, 128);
		colorRect(x_htabw + 1, imh - 1, tabw-2, 1, 0x000000, 128);
		colorRect(x_htabw, 0, 1, height, 0xffffff, 128);
		colorRect(pos_x + htabw - 1, 0, 1, height, 0x000000, 128);

		}
	}

 function onMouseDown(x,y,button,shift){
	if(Slider_vertical){
	//縦のとき
	focus();
	global.Layer.onMouseDown(...);

	var tabh = Slider_tabHeight;
	var htabh = tabh >> 1;
	var pos_y = int(
			(Slider_position-Slider_min) * (imageHeight - tabh - 2)/(Slider_max - Slider_min)) +
			htabh + 1;
	if(pos_y - htabh > y){
		// タブより上
		position = Slider_position - int((Slider_max - Slider_min)/ (tabh-2));
	}else if(pos_y + htabh < y){
		// タブより下
		position = Slider_position + int((Slider_max - Slider_min)/ (tabh-2));
	}else{
		// タブ
		// タブのドラッグを開始
		Slider_dragging = true;
		Slider_dragOriginX = y - pos_y;
		}

	}else{
		//横のときはスーパークラスのものでいい
		super.onMouseDown(...);
		}
	}

 function onMouseMove(x,y){
	if(Slider_vertical){

	global.Layer.onMouseMove(...);

	if(Slider_dragging){
		// タブをドラッグ
		position = int(
			(y - Slider_dragOriginX - (Slider_tabHeight >> 1)) * (Slider_max - Slider_min) /
			(imageHeight - Slider_tabHeight - 2) + Slider_min);
		}

	}else{
		super.onMouseMove(...);
		}
	}

 property vertical	{
	setter(v){
		Slider_vertical = v;
		update();
		}
	getter{
		return Slider_vertical;
		}
	}

 property Slider_tabHeight{
	setter(h){
		Slider_tabWidth = h;
		update();
		}
	getter{
		return Slider_tabWidth;
		}
	}

 property drawHighLight{
	setter(h){
		Slider_drawHighLight = h;
		update();
		}
	getter{
		return Slider_drawHighLight;
		}
	}

 property drawLine{
	setter(l){
		Slider_drawLine = l;
		update();
		}
	getter{
		return Slider_drawLine;
		}
	}

}

//position変化時にコールバックするexSliderLayer

class KAGPAexSliderLayer extends exSliderLayer{

	var Slider_callBack;

 function KAGPAexSliderLayer(win,par){
	super.exSliderLayer(...);
	}

 function finalize(){
	super.finalize(...);
	}

 function onChange(pos){
	super.onChange(pos);
	Slider_callBack(this,pos) if Slider_callBack !== void;
	}
 }

//クリック時にコールバックするButtonLayer
 
 class KAGPAButtonLayer extends ButtonLayer{

	var Butt_callBack;

 function KAGPAButtonLayer(win,par){
	super.ButtonLayer(...);
	}

 function finalize(){
	super.finalize(...);
	}

 function onClick(){
	super.onClick();
	Butt_callBack(this) if Butt_callback !== void;
	}
 }

//クリック時にコールバックするCHeckBoxLayer

class KAGPACheckBoxLayer extends CheckBoxLayer{

	var CheckBox_callBack;

 function KAGPACheckBoxLayer(win,par){
	super.CheckBoxLayer(...);
	}

 function finalize(){
	super.finalize(...);
	}

 function onMouseDown(){
	super.onMouseDown(...);
	CheckBox_callBack(this,CheckBox_checked) if CheckBox_callback !== void;
	}

 function onKeyDown(key,shift,process){
	super.onKeyDown(...);
	if(process&&(key == VK_RETURN||key==VK_SPACE)){
		CheckBox_callBack(this,CheckBox_checked) if CheckBox_callback !== void;
		}
	}
 }
 
