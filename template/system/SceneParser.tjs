var LINEMODE_NONE = 0;
var LINEMODE_PAGE = 1;
var LINEMODE_LINE = 2;
var LINEMODE_VN   = 3;
var LINEMODE_TEX  = 4;
var LINEMODE_FREE = 5;

/**
 * シーン再生用パーサ
 * KAG 形式でかかれたシナリオデータを
 * linemode に応じて改行処理を適切に行って再生用の状態に変換するパーサ
 *
 * ボイスの自動処理機能を持つ
 * - ボイスはあらかじめ一覧リストを準備する必要がある(ボイスのファイル名リストをつくっておく)
 * - キャラクタ毎にボイス用の定義をあらかじめくんでおくこと
 */
class SceneParser extends KAGParser
{
	var lines; // パース結果
	var errors; // エラー結果

    /**
     * @param lineMode
     * 1:行単位で [p]
     * 2:行単位で [l] 手動で [p]
     * 3:行単位で [l] 空行で [p]
     * 4:改行は無視。空行で [p]
     * 5:改行は [r] 。空行で [p]
     */
	var lineMode;    // 改行処理モード
	var crAfterName; // 名前の後に改行をいれるか
	var erAfterPage; // 改ページ直後に画面消去するか
	var saveBeforeName; // 名前の直前にセーブポイントをいれる
    var autoIndent;  // 「『で自動的にインデントする
	var voiceDefault;  // ボイスデフォルト値

	var voiceMap = %[];      // ボイス状態記録マップ

	var noCrOnce;    // 改行処理を１回なしにする
	var noErOnce;    // 画面消去処理を１回なしにする
    var afterPage;   // 改ページ直後
	var doLine;      // 入力待ち実行指示
	var emptyLine;     // まだ行が空
	var commandLine;   // コマンドが実行された行
    var prevEmptyLine; // 前の空行状態

    var nameMode;       // 名前処理モード
    var nameStr;        // 現在の名前
    var nameDisp;       // 現在の表示名
	var afterName;
	var nameInfos = []; // 登録済みの名前
	var overvoiceInfos = []; // ボイス上書き司令

	var currentText; // 現在表示中のテキスト
	
	// -------------------------------------------------------------

	/**
	 * コンストラクタ
	 */
	function SceneParser() {
		super.KAGParser(...);
	}

	/**
	 * 初期化処理
	 */
	function init() {
		lines = [];
		errors = [];
		(Dictionary.clear incontextof voiceMap)(); 
		noCrOnce = false;
		noErOnce = false;
		afterPage = true;
		doLine = false;
		emptyLine = true;
		commandLine = false;
		prevEmptyLine = true;
		nameMode  = 0;
		afterName = false;
		nameInfos.clear();
		overvoiceInfos.clear();
		voiceBase = "";
		currentText = "";
	}

	/**
	 * 全情報消去
	 */
	function clear() {
		super.clear();
		init();
	}
	
	// -------------------------------------------------------------

	/**
	 * タグの追加
	 */
	function enqueueTag(tag) {
		lines.add(tag);
	}
	
	/**
	 * タグの追加（コピー処理する）
	 */
	function addTag(name, elm) {
		if (currentText.length > 0) {
			lines.add(%[tagname:"ch", text:currentText]);
			currentText = "";
		}
        var e = %[];
        if (elm !== void) {
            (Dictionary.assign incontextof e)(elm, false);
        }
        e.tagname = name if name !== void;
		//dm("タグ追加:" + e.tagname);
		lines.add(e);
    }

	// ------------------------------------------------

	/**
	 * エラー
	 * @param type 種類
	 * @param msg メッセージ
	 */
	function error(type, msg) {
		errors.add(curStorage + ":" + curLine + ":(" + type + ") " + msg);
	}

	// ------------------------------------------------

	var voiceInfos; // ボイス展開用情報
	var voiceBase;  // ボイス展開時のベース値
	var voiceNameMap;   // ボイス展開用マップ
	var labelMap;       // ラベル固有のIDを保持するマップ

	/**
	 * 指定キャラの現在のボイス情報を返す
	 * @param name キャラ名
	 * @return ボイスファイル名
	 */
	function getCurrentVoice(name) {
		//dm("ボイス情報取得:" + name);
		var info = voiceMap[name];
		if (info == void) {
			if (voiceDefault !== void) {
				info = %[];
				voiceMap[name] = info;
				info.voice = voiceDefault;
			}
		}					
		var voice;
		if (info !== void) {
			if (info.strVoice !== void) {
				// 文字列指定
				dm("文字列指定:" + info.strVoice);
				if (info.strVoice != "ignore") {
					voice = info.strVoice;
				}
				info.strVoice = void;
			} else if (info.voice !== void) {
				voice = info.voice;
				info.incVoice = true;
			}
			if (info.incVoice) {
				if (info.voice >= 0) {
					info.voice++;
				}
				info.incVoice = void;
			}
			if (typeof voice == "Integer") {
				// 数値指定の場合は規定に従って変換
				var vinfo = voiceInfos[name];
				var voiceFile = vinfo !== void ? vinfo.filename : void;
				if (voiceFile !== void) {
					voice = voiceFile.sprintf(voiceBase, voice, "");
				}
			}
		}
		return voice;
	}

	/**
	 * 名前のエントリ。これで登録されたものは、
	 * テキスト表示または playvoice 命令でボイス再生されます。
	 * @param name 名前
	 * @param disp 表示名
	 */
	function entryName(name, disp) {
		var info = %[];
		info.name = name;
		info.disp = disp if disp !== void;
		// ボイス情報の展開
		var voice = getCurrentVoice(name);
		if (typeof voice == "String") {
			if (voiceNameMap !== void) {
				voice = voice.toUpperCase();
				var v;
				if ((v = voiceNameMap[voice]) !== void) {
					info.voice = v;
					if ((v = voiceNameMap[voice + "N"]) !== void) {
						info.voicen = v;
					}
				} else {
					error("voice", "ボイスファイルがありません:" + voice);
				}
			} else {
				if (isExistVoiceName(voice)) {
					info.voice = voice;
					// デフォルト名以外用の別ボイスがある場合
					if (isExistVoiceName(voice + "N")) {
					info.voicen = voice + "N";
					}
				} else {
					error("voice", "ボイスファイルがありません:" + voice);
				}
			}
		}
		nameInfos.add(info);
	}

	/**
	 * ボイス強制指定の追加
	 */
	function entryOverVoice(voice) {
		var info = %[];
		if (nameInfos.count > 0) {
			info.name = nameInfos[nameInfos.count-1].name;
			info.disp = nameInfos[nameInfos.count-1].disp;
		}
		if (voiceNameMap !== void) {
			var v = voiceNameMap[voice.toUpperCase()];
			if (v !== void) {
				info.voice = v;
			} else {
				error("voice", "ボイスファイルがありません:" + voice);
			}
		} else {
			if (isExistVoiceName(voice)) {
				info.voice = voice;
			} else {
				error("voice", "ボイスファイルがありません:" + voice);
			}
		}
		overvoiceInfos.add(info);
	}
	
	// 正規表現
	var reNumber = new RegExp("^[0-9][0-9]*$");
	// ボイスコマンド扱い
	var voiceCmds = %[ tagname:true, replace:true, once:true, entry:true ];
	
	/**
	 * ボイス番号指定のパース
	 */
	function parseVoice(elm) {
		var names = [];
		names.assign(elm);
		for (var i=0;i<names.count;i+=2) {
			var name  = names[i];
			var value = names[i+1];
			if (voiceCmds[name] !== void) {
				continue;
			}
			var info = voiceMap[name];
			if (info == void) {
				info = %[];
				voiceMap[name] = info;
			}
			if (value == "clear") {
				delete info.strVoice;
				delete info.voice;
				delete info.incVoice;
			} else if (value == "ignore") {
				info.strVoice = "ignore";
			} else if (reNumber.test(value)) {
				// 数値指定の場合
				if (elm.once || elm.replace) {
					info.strVoice = +value;
				} else {
					info.voice = +value;
				}
			} else {
				info.strVoice = value;
			}
			info.incVoice = elm.replace;
			// 再生指定
			if (elm.entry) {
				entryName(name);
			}
		}
	}

	/**
	 * 強制再生処理(playvoice コマンド)
	 */
	function parsePlayvoice(elm) {
		if (nameInfos.count > 0) {
			for (var i=0;i<nameInfos.count;i++) {
				var info = nameInfos[i];
				if (info.voice !== void) {
					addTag("entryvoice", info);
				}
			}
			nameInfos.clear();
		}
		addTag("playvoice");
	}

	/**
	 * 強制ボイス指定用(entryvoice コマンド)
	 */
	function parseEntryvoice(elm) {
		if (elm.name !== void && elm.voice !== void) {
			var voice = elm.voice;
			var info = %[];
			info.name = elm.name;
			if (typeof voice == "String") {
				if (voiceNameMap !== void) {
					voice = voice.toUpperCase();
					var v;
					if ((v = voiceNameMap[voice]) !== void) {
						info.voice = v;
						if ((v = voiceNameMap[voice + "N"]) !== void) {
							info.voicen = v;
						}
					} else {
						error("voice", "ボイスファイルがありません:" + voice);
					}
				} else {
					if (isExistVoiceName(voice)) {
						info.voice = voice;
						// デフォルト名以外用の別ボイスがある場合
						if (isExistVoiceName(voice + "N")) {
							info.voicen = voice + "N";
						}
					} else {
						error("voice", "ボイスファイルがありません:" + voice);
					}
				}
			}
			nameInfos.add(info);
		}
	}
	
	/**
	 * テキストのパース処理
	 */
    function parseCh(elm) {
		// 名前表示専用処理
		//【キャラクタ名/表示名】を検出して名前表示処理を実行する
		if (nameMode > 0) {
			// 既に名前表示ロジックに入ってる
			// ここでは emptyLine の状態はありえない
			if (elm.text == "】") {
				nameMode = 0;
				entryName(nameStr, nameDisp);
				afterName = true;
				return;
			} else {
				if (nameMode == 1) {
					if (elm.text == "/") {
						nameMode = 2;
						return;
					} else {
						nameStr += elm.text;
                    }
                } else {
                    nameDisp += elm.text;
                }
            }
            return;

		} else if (emptyLine) {

			// 行頭

			// 改行指示がある
			if (doLine) {
				parseL();
				doLine = false;
			}

			if (elm.text == "【") {
				nameMode = 1;
				nameStr  = "";
				nameDisp = "";
				return;
            } else {
				nameMode = 0;
				// 名前指定がない場合はパラメータなしで名前処理を呼び出す
				if (nameInfos.count == 0 && (lineMode <= LINEMODE_VN || prevEmptyLine)) {
					nameInfos.add(%[]);
				}
			}
		}

		// ラインモード処理
        var erflag;
        // テキストクリア処理
		switch (lineMode) {
        case LINEMODE_PAGE:
			if (emptyLine) {
				erflag = true;
            }
            break;
        case LINEMODE_LINE:
        case LINEMODE_VN:
        case LINEMODE_FREE:
			if (afterPage) {
                afterPage = false;
                if (emptyLine) {
                    erflag = true;
                }
			} else {
				if (emptyLine) {
					addTag("r");
				}
            }
            break;
        case LINEMODE_TEX:
            if (afterPage) {
                afterPage = false;
                erflag = true;
            }
            break;
        }
		if (erflag && !erAfterPage) {
			addTag("er");
        }

		// 名前表示の展開
		if (nameInfos.count > 0) {
			addTag("msgon");
			var i;
			for (i=0;i<nameInfos.count-1;i++) {
				var info = nameInfos[i];
				if (info.voice !== void) {
					addTag("entryvoice", info);
				}
			}
			var info;
			// ボイスの上書き指定
			if (overvoiceInfos.count > 0) {
				//dm("ボイス上書き指定");
				info = overvoiceInfos[0];
				overvoiceInfos.erase(0);
			} else {
				info = nameInfos[i];
			}
			//dm("dispname:" + info.name);
			if (saveBeforeName) {
				addTag("savepoint");
			}
			addTag("dispname", info);
		}
		
		// 文字登録
		currentText += elm.text;
		//addTag("ch", elm);
		emptyLine = false;

		// 自動インデント処理
		if (autoIndent && nameInfos.count > 0 && (elm.text == "「" || elm.text == "『")) {
			addTag("indent");
		}
		nameInfos.clear();
		afterName = false;
        return;
    };

	/**
	 * 改行のパース処理
	 */
	function parseR(elm) {

		if (!elm.eol) {
			// 改行指示がある
			if (doLine) {
				parseL();
				doLine = false;
			}
			addTag("r", elm);
			return;
		}

		// 改行効果を一度だけ無視させる
		if (noCrOnce) {
			noCrOnce = false;
			prevEmptyLine = emptyLine;
			emptyLine = true;
			commandLine = false;
            return;
        }

		nameMode = 0;
		if (crAfterName && afterName) {
			commandLine = false;
			return;
		}
		switch (lineMode) {
		case LINEMODE_PAGE:
			//dm("page:改行");
			if (emptyLine) {
				if (!commandLine) {
					prevEmptyLine = emptyLine;
				}
			} else {
				// 名前の直後の改行は無視する
				prevEmptyLine = emptyLine;
				parseP(elm);
			}
            break;
		case LINEMODE_LINE:
			//dm("line:改行");
            if (emptyLine) {
				if (!commandLine) {
					prevEmptyLine = emptyLine;
				}
			} else {
				// 名前の直後の改行は無視する
				prevEmptyLine = emptyLine;
				emptyLine = true;
				parseL();
			}
			break;
        case LINEMODE_VN:
            //dm("vn:改行");
            if (emptyLine) {
                if (!prevEmptyLine) {
					if (!commandLine) {
						// 最初の空行で改ページ
						doLine = false;
						prevEmptyLine = emptyLine;
						parseP(elm);
					}
                } else {
                    // そうでない空行は無視する
                    prevEmptyLine = emptyLine;
                }
            } else {
				// 名前の直後の改行は無視する
				prevEmptyLine = emptyLine;
				emptyLine = true;
				doLine = true;
            }
            break;
		case LINEMODE_TEX:
		case LINEMODE_FREE:
			//dm("tex/free:改行");
            if (emptyLine) {
				if (!commandLine) {
					if (!prevEmptyLine) {
						// 最初の空行で改ページ
						prevEmptyLine = emptyLine;
						parseP(elm);
					} else {
						// そうでない空行は無視する
						prevEmptyLine = emptyLine;
					}
				}
            } else {
				prevEmptyLine = emptyLine;
				emptyLine = true;
            }
		}
		commandLine = false;
		return;
	}

	function parseL() {
		addTag("l", %[voicewait:true]);
		addTag("afterline");
	}

	function parseL2(elm) {
		if ((lineMode == LINEMODE_VN || lineMode == LINEMOE_TEX) && nameStr != "") {
			parseL();
			entryName(nameStr, nameDisp);
		} else {
			addTag(void, elm);
		}
	}
	
	/**
	 * p タグの展開
	 */
    function parseP(elm) {
		// 自動インデント解除
		if (autoIndent) {
			addTag("endindent");
		}
		// 改ページ処理無視フラグ
		if (!noErOnce) {
			addTag("p", elm);
			addTag("afterpage");
			if (erAfterPage) {
				if (!saveBeforeName) {
					addTag("savepoint");
				}
				addTag("er");
			}
		} else {
			addTag("p", elm);
			addTag("afterpage");
			noErOnce = false;
		}
		afterPage = true;
		emptyLine = true;
		commandLine = false;
		nameStr  = "";
		nameDisp = "";
	}

	var textTags = %[
	ch:parseCh incontextof this,
	r:parseR incontextof this,
	p:parseP incontextof this,
	l:parseL2 incontextof this,
	nor: function(elm) { noCrOnce = true; return 0; } incontextof this,
	noer: function(elm) { noErOnce = true; return 0; } incontextof this,
		];

	var extractTags = %[
	voice:parseVoice incontextof this,
	voicebase: function(elm) {
		voiceBase = elm.base;
		(Dictionary.clear incontextof voiceMap)(); 
		return 0;
	} incontextof this,
	playvoice: parsePlayvoice incontextof this,
	entryvoice: parseEntryvoice incontextof this,
		];

	
	/**
	 * パース用オプション設定
	 * @param elm 基本パラメータ
	 * パラメータ
	 * lineMode    行モード指定（必須）
	 * erAfterPage ページの直後に画面消去
	 * crAfterName 名前の後の改行を無視
	 * saveBeforeName 名前の前で保存
	 * autoIndent  "「" による自動インデントを有効にする
	 * voice       ボイスカウントの初期値
	 */
	function setOption(elm) {

		if (elm.lineMode == "page") {
			lineMode = LINEMODE_PAGE;
		} else if (elm.lineMode == "line") {
			lineMode = LINEMODE_LINE;
		} else if (elm.lineMode == "vn") {
			lineMode = LINEMODE_VN;
		} else if (elm.lineMode == "tex") {
			lineMode = LINEMODE_TEX;
		} else if (elm.lineMode == "free") {
			lineMode = LINEMODE_FREE;
		} else {
			lineMode     = +elm.linemode;
		}
		erAfterPage  = elm.erafterpage;
		crAfterName  = elm.craftername;
		saveBeforeName = elm.saveBeforeName;
		autoIndent   = elm.autoindent;
		voiceDefault = +elm.voice if elm.voice !== void;
		//dm("lineMode:" + lineMode);
		//dm("erAfterPage:" + erAfterPage);
		//dm("crAfterName:" + crAfterName);
		//dm("autoIndent:"  + autoIndent);
		//dm("voiceDefault:" + voiceDefault);
	}

	/**
	 * マクロ用のパース実行
	 * @param storage 対象ファイル
	 */
	function parseMacro(storage) {
		dm("シーン用のマクロをパース:" + storage);
		ignoreCR  = true;
		loadScenario(storage);
		while (getNextTag() !== void) {} // 次のタグを得る
	}
	
	/**
	 * 全パース処理実行
	 * @param storage 対象ファイル
	 * @param voiceInfos ボイス情報
	 * @param voiceBase ボイスベース値（省略時はボイス情報から抽出）
	 * @param voiceNameMap ボイスファイル名置換情報（省略時は無視)
	 */
	function parse(storage, voiceInfos, voiceBase, voiceNameMap, labelMap) {
		init();
		this.voiceInfos   = voiceInfos;
		this.voiceNameMap = voiceNameMap;
		this.labelMap     = labelMap;
		if (voiceBase !== void) {
			this.voiceBase = voiceBase;
		}
		ignoreCR = false;
		loadScenario(storage);
		var runLine = 0;
		var obj;
		try {
			while ((obj = getNextTag()) !== void) { // 次のタグを得る
				if (runLine !== curLine) {
					//dm(curLine + ":" + curLineStr);
					//enqueueTag(%[tagname:"line", line:curLine]);
					runLine = curLine;
				}
				var func = textTags[obj.tagname];
				if (func !== void) {
					func(obj);
				} else {
					// 改行指示がある場合はそれを実行
					if (doLine) {
						parseL();
						doLine = false;
					}
					commandLine = true;
					func = extractTags[obj.tagname];
					if (func !== void) {
						func(obj);
					} else {
						// タグがあったらさっくりなしに
						noErOnce = false;
						addTag(void, obj);
					}
				}
			}
		} catch (e) {
			error("error", e.message);
		}
@if(false)
		for (var i=0;i<lines.count;i++) {
			if (lines[i].tagname == "line") {
				dm("パース結果:" + lines[i].tagname + ":" + lines[i].line);
			} else if (lines[i].tagname == "label") {
				dm("パース結果:" + lines[i].tagname + ":" + lines[i].label);
			} else {
				dm("パース結果:" + lines[i].tagname);
			}
		}
@endif
		return lines;
	}

	/**
	 * ラベル通過
	 */
	function onLabel(label, page) {
		//dm("ラベル登録:" + label + ":" + curLine);
		if (labelMap !== void) { // ラベルのカウント処理を行う
			var count;
			var labelName = curStorage + label;
			count = labelMap[labelName];
			if (count === void) {
				count = labelMap.count++;
				labelMap[labelName] = count;
			}
			enqueueTag(%[tagname:"label", label:label, page:page, line:curLine, count:count]);
		} else {
			enqueueTag(%[tagname:"label", label:label, page:page, line:curLine]);
		}
		return true;
	}
}
