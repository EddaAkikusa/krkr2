/**
 * 環境SEオブジェクト
 */
class KAGEnvSE extends KAGEnvObject {

	var id;
	var count; // 参照されたカウント値

	var storage;   // 参照しているファイル名
	var volume;    // 音量
	var loop;      // ループ指定
	var start;     // 開始指定

	var transTime; // 変動時間
	var waitFade;  // フェード待ち指定
	var wait;      // 終了待ち指定
	
	var replay;  // 再生指定
	var refade;  // 音量指定
	
    /**
     * コンストラクタ
     */
    function KAGEnvSE(env, id) {
		super.KAGEnvObject(env, void);
		this.id = id;
    }

	function init() {
		name = void;
		count = 0;
		replay = true;
		storage = void;
		transTime = void;
	}
	
    /**
     * 再生処理
     * @param param 再生対象ファイル
     */
	function setPlay(param, elm) {
		if (param !== void) {
			replay  = true;
			if (!isSkip() || elm.loop || !env.nosewhenski) {
				storage   = param;
				volume    = elm.volume !== void ? +elm.volume : 100;
				loop      = elm.loop;
				start     = elm.start;
				transTime = +elm.time if elm.time !== void;
			} else {
				storage = void;
			}
		}
	}

    /**
     * 停止処理
     * @param param フェードアウト時間
     */
	function setStop(param, elm) {
		replay    = true;
		storage   = void;
		transTime = elm.time !== void ? +elm.time : +param;
    }

    /**
     * 音量フェード
     * @param param フェード時間
     */
	function setFade(param, elm) {
		refade    = true;
		volume    = param;
		transTime = elm.time !== void ? +elm.time : +param;
    }

    /**
     * 終了待ち
     */
    function setWait(param, elm) {
		wait = %[];
        (Dictionary.assign incontextof wait)(elm, false);
        wait.buf = id;
        if (wait.canskip === void) {
            wait.canskip = true;
        }
    }

    /**
     * フェード終了待ち
     */
	function setWaitFade(param, elm) {
		waitFade = %[];
		(Dictionary.assign incontextof waitFade)(elm, false);
		waitFade.buf = id;
		if (waitFade.canskip === void) {
			waitFade.canskip = true;
		}
    }

    var secommands = %[
	tagname : null, 
    storage : setPlay incontextof this,
    play : setPlay incontextof this,
    stop : setStop incontextof this,
    fade : setFade incontextof this,
	volume : setFade incontextof this,
	wait : setWait incontextof this,
    waitfade : setWaitFade incontextof this,
    loop : null,
    time : null,
    start : null,
    canskip : null,
        ];

    /**
     * コマンドの実行
     * @param cmd コマンド
     * @param param パラメータ
     * @param elm 他のコマンドも含む全パラメータ
     * @return 実行が行われた場合 true
     */
	function doCommand(cmd, param, elm) {
		var func;
		if ((func = secommands[cmd]) !== void) {
			if (func != null) {
				func(param, elm);
				return true;
            }
			return false;
        }
        // 再生コマンドとみなす
		setPlay(cmd, elm);
        return true;
    }

    /**
     * KAG タグ処理
     * @param elm 引数
     */
	function tagcommand(elm) {
		// dm("SE 用ファンクション呼び出し!");
		wait = void;
		waitFade = void;
		transTime = void;
		var doflag = false;
		var names = [];
		names.assign(elm);
		for (var i=0; i<names.count; i+= 2) {
			if (doCommand(names[i], names[i+1], elm)) {
				doflag = true;
			}
		}
		if (!doflag && elm.tagname != "se") {
			setPlay(elm.tagname, elm);
        }
    }

	function sync() {
		var time = isSkip() ? 0 : transTime;
		if (replay) {
			if (storage !== void) {
				env.playSE(id, time, %[storage:storage, loop:loop, start:start]);
			} else {
				env.stopSE(id, time);
			}
			replay = false;
			refade = false;
		} else if (refade) {
			env.fadeSE(id, time, volume);
			refade = false;
		}
		if (waitFade !== void) {
			return env.waitSEFade(waitFade);
		} else if (wait !== void) {
			return env.waitSEStop(wait);
		}
		return 0;
	}

};
